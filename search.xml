<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python 的退一步调用(后备机制)]]></title>
    <url>%2F2018%2F04%2F02%2Fcjficuhbi0003e3lvz8cs8ktg%2F</url>
    <content type="text"><![CDATA[序列的增量运算+=背后的特殊方法是__iadd__(用于“就地加法”)。但是如果一个类没有实现这个方法的话, Python会退一步调用add。考虑下面这个简单的表达式: 1&gt;&gt;&gt; a += b 如果 a 实现了 __iadd__方法，就会调用这个方法：对list、bytearray 和 array.array 等可变序列来说，a 就会就地改动，就像调用了 a.extend(b)一样。 但是如果 a 没有实现__iadd__的话，a += b 这个表达式的效果就变得跟 a = a + b一样了：首先计算 a + b,得到一个新的对象，然后赋值给 a。 序列：虽然没有 __iter__ 方法，但是 Foo 示例是可迭代的对象，因为发现有 __getitem__ 方法时，python 会调用它，传入从0开始的整数索引，尝试迭代对象(这是一种后备机制)。 12345678910111213class Foo: def __getitem__(self, pos): return range(0, 30, 10)[pos]f = Foo()print(f[1])for i in f: print(i)print(20 in f)print(15 in f) 输出： 12345671001020TrueFalse[Finished in 0.1s] 尽管没有实现__contains__方法，但是 Python 足够智能，会调用 __getitem__ 方法，设法让迭代和 in 运算符可用。]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图解 HTTP 笔记]]></title>
    <url>%2F2018%2F03%2F22%2Fcjficuhe20038e3lv5xavjiiv%2F</url>
    <content type="text"><![CDATA[keep-alive管道化（pipelining），并行发送请求 如何实现？ 分块传输逐步显示页面 获取部分内容的范围请求请求首部字段range，指定资源byte范围可以断点续传 URI有斜杠和没有斜杠todo 特殊的状态码：304: 附带条件请求后，服务器资源未变，可直接用客户端缓存（与3xx的重定向无关） 307:与302相同，但遵照浏览器标准，不会从POST变为GET 代理服务器：不改变内容，直接转发，会追加写入via信息透明代理：不加工报文（via信息）；缓存代理：除缓存外，还可针对特定网站的访问控制 cache-control：响应指令中的no-cache： 必须向源服务器进行资源**有效期确认** no-store：包含机密信息，真正的不进行缓存 HTTPS：1. 中间人攻击：传输过程中被拦截并篡改内容，（可使用 md5和 sha-1等散列校验完整性） 2. SSL 和 TLS：除了 HTTP，其他如 SMTP、Telnet 等均可配合 SSL 使用 3. 公钥进行加密，私钥进行解密 （大整数因式分解） 4. https 使用混合加密机制（非对称密钥复杂，处理速度慢）： 1. 使用非对称密钥加密对称密钥并传输 2. 在后续通信中使用对称密钥加密 5. 基于表单认证（session 的管理）： 1. 将 sessionid 发给用户作为 cookie 的一部分 2. 用户再次携带 cookie（sessionid）请求 3. 服务器识别 sessionid 判断用户状态 4. 基于 HTTP 的协议1. 谷歌的 SPDY（优化 http 瓶颈）； 1. 赋予请求优先级 2. 压缩 http 首部 3. 服务器主动推送功能 4. 另外：ajax（局部刷新）comet（服务器延迟响应以实现推送） 2. webSocket： 1. 使用浏览器全双工通信 2. 需要用到 HTTP 的 Upgrade 首部字段 3. webDAV（ web服务器管理文件） POST的非幂等性重复操作请求后的副作用是否相同？GET、DELETE、PUT 等方式请求一次和多次后的结果是相同的，而多次POST会产生不同的副作用，如在网站上发表多篇相同的文章]]></content>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ajax的无刷新文件下载]]></title>
    <url>%2F2018%2F03%2F21%2Fcjficuhbs0008e3lvgnymlx53%2F</url>
    <content type="text"><![CDATA[1.使用ajax，ajax的返回值类型是json,text,html,xml类型，或者可以说ajax的发送，接受都只能是string字符串，不能流类型，所以无法实现文件下载，强用会出现response冲突。 如果非要使用ajax的话，只能通过返回值得到生成的文件相关url。然后在回调函数里通过创建一个iframe，并设置其src值为文件url，或者一个对文件生成流的处理url，这样操作来实现文件下载且页面无刷新。 2.不使用ajax，通过dom动态操作或创建iframe,form的方式来实现，在下载文件的同时实现页面不刷新，其中iframe的src可以是文件地址url来直接下载文件，也可以是流处理url通过response流输出下载，form的是流处理url通过response流输出下载，dom动态操作的时候实现文件下载，且页面无刷新。 要在下载的同时实现进度条的话，可以创建一个定时任务，每隔一定时间就向后台发送请求，通过公用的对象，比如session,来取得文件下载的处理进度。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Python 中的 '__Getitem__', '__Contains__' 以及 ‘In’]]></title>
    <url>%2F2018%2F03%2F19%2Fcjficuhcw001de3lv6n3a8xpb%2F</url>
    <content type="text"><![CDATA[实现 __getitem__python3中，实现了 __getitem__后，类便可以执行遍历和切片操作，此处是转移到类的一个内部变量上，且在切片时传给__getitem__的参数 value 是一个 slice，因此可以执行self.n[value]操作。 12345678910class A: def __init__(self): self.n = [1,2,3] def __getitem__(self, value): print(&apos;value:&apos;,value) return self.n[value]a = A()print(a[1:2]) 运行结果： 123value: slice(1, 2, None)[2][Finished in 0.1s] 关于 in 操作关于 in 操作，当 a 实现了__getitem__,可以切片和遍历时，python 会遍历a的元素来判断结果。(此时__contains__被注释) 12345678910111213class A: # def __contains__(self,num): # return True def __init__(self): self.n = [1,2,3] def __getitem__(self, value): print(&apos;value:&apos;,value) return self.n[value]a = A()print(4 in a) 运行结果：从 print 信息可以看出求 in 过程中遍历了a。 123456value: 0value: 1value: 2value: 3False[Finished in 0.1s] 实现 __contains__当取消 __contains__ 的注释后，在求 in 操作时python 会直接执行__contains__函数。此时__contains__被设定为永远返回 Ture，即使 4 并不在 [1,2,3] 中，也返回了 True。 12345678910111213class A: def __contains__(self,num): return True def __init__(self): self.n = [1,2,3] def __getitem__(self, value): print(&apos;value:&apos;,value) return self.n[value]a = A()print(4 in a) 运行结果： 12True[Finished in 0.1s]]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最简单理解 Python 中的深浅拷贝]]></title>
    <url>%2F2018%2F03%2F18%2Fcjficuhea003oe3lvl1hihspd%2F</url>
    <content type="text"><![CDATA[python 中的深浅拷贝1234567891011121314151617181920import copya = [1, 2, 3, 4, [&apos;a&apos;, &apos;b&apos;]] #原始对象b = a #赋值，传对象的引用c = copy.copy(a) #对象拷贝，浅拷贝d = copy.deepcopy(a) #对象拷贝，深拷贝a.append(5) #修改对象aa[4].append(&apos;c&apos;) #修改对象a中的[&apos;a&apos;, &apos;b&apos;]数组对象print &apos;a = &apos;, aprint &apos;b = &apos;, bprint &apos;c = &apos;, cprint &apos;d = &apos;, d输出结果：a = [1, 2, 3, 4, [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;], 5]b = [1, 2, 3, 4, [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;], 5]c = [1, 2, 3, 4, [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]]d = [1, 2, 3, 4, [&apos;a&apos;, &apos;b&apos;]] python 快速排序123456789101112#coding:utf-8def quicksort(list): if len(list)&lt;2: return list else: midpivot = list[0] lessbeforemidpivot = [i for i in list[1:] if i&lt;=midpivot] biggerafterpivot = [i for i in list[1:] if i &gt; midpivot] finallylist = quicksort(lessbeforemidpivot)+[midpivot]+quicksort(biggerafterpivot) return finallylistprint quicksort([2,4,6,7,1,2,5])]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django 项目部署到全新的Ubuntu]]></title>
    <url>%2F2018%2F03%2F04%2Fcjficuhby000ce3lvqhstmea6%2F</url>
    <content type="text"><![CDATA[安装必要包 12345apt-get install Mysql-clientapt-get install Mysql-server,并授权远程连接apt-get install python3-pipapt-get install python3.4-venvapt-get install git 先 pip install —upgrade pip避免错误 1pip install -r requirement.txt 其中： 分页插件 pure-pagination 有bug，需要手动安装 1git clone https://github.com/jamespacileo/django-pure-pagination.git 并修改setup.py源码(添加,encoding=&#39;utf-8&#39;)后手动执行安装 12with open(os.path.join(os.path.dirname(__file__), &apos;README.rst&apos;),encoding=&apos;utf-8&apos;) as readme: README = readme.read() 1python3 setup.py install Pillow 依赖 zlib，需要先 1apt-get install zlib1g-dev 使用 Navicat 传输整个数据库到服务器。 配置django settings: 123456DEBUG=False # 关闭debug# 开启与注释相应设置，将静态文件交给apache代理STATIC_ROOT = os.path.join(BASE_DIR, &apos;static/&apos;) #STATICFILES_DIRS = [# os.path.join(BASE_DIR, &quot;static&quot;)#] 根据此文操作把Django搭建到Apache服务器 最开始将python依赖包安装到了虚拟环境中，并不能使用上文参考链接(自强学堂)中的方法成功启动。舍去虚拟环境，将依赖包直接安装到ubuntu中后成功。 文中介绍方法：在apache mysite.conf中指明python虚拟环境路径。 123WSGIScriptAlias / /home/tu/blog/blog/wsgi.pyWSGIDaemonProcess ziqiangxuetang.com python-path=/home/tu/blog:/home/tu/.virtualenvs/blog/lib/python2.7/site-packagesWSGIProcessGroup ziqiangxuetang.com 实测无效，可能是由于 virtualenv 和 venv 的差异导致。]]></content>
      <tags>
        <tag>Python</tag>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 笔记]]></title>
    <url>%2F2018%2F02%2F23%2Fcjficuhc5000ke3lv6indt10s%2F</url>
    <content type="text"><![CDATA[经典的爬楼梯问题（斐波那契数列） 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; //逆向递归方法会超时 // public int climbStairs(int n) &#123; // if (n==1) return 1; // if (n==2) return 2; // return climbStairs(n-1) + climbStairs(n-2); // &#125; // //顺向累加可以// public int climbStairs(int n) &#123;// if (n==1) return 1;// int last = 1, lastlast = 1;// int now = 0;// for(int i=2;i&lt;=n;i++)&#123;// now = last + lastlast;// lastlast = last;// last = now;// &#125;// return now; // &#125; //记忆化搜索，每一步都记录下来了 public int climbStairs(int n) &#123; int[] result = new int[n+2]; result[1] = 1; result[2] = 2; for(int i=3;i&lt;=n;i++)&#123; result[i] = result[i-1] + result[i-2]; &#125; return result[n]; &#125; &#125;]]></content>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 树 笔记]]></title>
    <url>%2F2018%2F02%2F22%2Fcjficuhbz000ee3lvjwkbmujl%2F</url>
    <content type="text"><![CDATA[二叉树的层次遍历 新建数组level 将Queue中每个node： 插入 level 子node入Queue 将level插入result Queue中始终只有该层的node，每次循环将全部poll，并offer下一层的全部node 12345678910111213141516171819202122232425262728293031323334353637/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; List result = new ArrayList(); if (root == null) return result; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;(); queue.offer(root); while (!queue.isEmpty())&#123;//只要上层中有一个node的子node不是空 ArrayList&lt;Integer&gt; level = new ArrayList&lt;Integer&gt;(); int size = queue.size(); //poll过程中size会变，需要提前求出 for(int i=0;i&lt;size;i++)&#123; TreeNode head = queue.poll(); level.add(head.val); if (head.left != null)&#123; queue.offer(head.left); &#125; if (head.right != null)&#123; queue.offer(head.right); &#125; &#125; result.add(level); &#125; return result; &#125;&#125; 将数组转为 BSTTODO：关于边界的控制 自己的代码问题： (mid+left)/2的操作太难理清边界 不能兼顾左右 右边起始可能需要 mid+1？ 12345678910111213141516171819202122232425262728293031323334353637/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode sortedArrayToBST(int[] nums) &#123; int left = 0; int right = nums.length; int mid = (left + right)/2; TreeNode root = new TreeNode(nums[mid]); buildChild(nums, root, left, right); return root; &#125; public void buildChild(int[] nums, TreeNode root ,int left, int right)&#123; int mid = (left + right)/2; if (left &lt; mid) &#123; root.left = new TreeNode(nums[(mid+left)/2]); buildChild(nums, root.left, left, mid); &#125; if (mid &lt; right-1) &#123; root.right = new TreeNode(nums[(mid+right)/2]); buildChild(nums, root.right, mid+1, right); &#125; &#125;&#125; 正确答案： 123456789101112131415161718192021222324public class Solution &#123; /* * @param A: an integer array * @return: A tree node */ public TreeNode sortedArrayToBST(int[] A) &#123; if (A == null)&#123; return null; &#125; return helper(A, 0, A.length); &#125; private TreeNode helper(int[] A, int start, int end)&#123; if (start &gt;= end)&#123; return null; &#125; int mid = (start + end - 1) &gt;&gt; 1; TreeNode node = new TreeNode(A[mid]); node.left = helper(A, start, mid); node.right = helper(A, mid + 1, end); return node; &#125;&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 链表笔记]]></title>
    <url>%2F2018%2F02%2F22%2Fcjficuhc8000re3lvfpgr3w5s%2F</url>
    <content type="text"><![CDATA[反转单向链表各种方法都需要三个指针，此方法比较简洁 while循环中的4行代码各个变量收尾相连 123456789class Solution: def reverse(self, head): curt = None while head != None: temp = head.next head.next = curt curt = head head = temp return curt 融合 2 个有序链表l1和l2完全并列而不是l2插入到l1的关系整体干净、工整且对称边界判断较少 新建链表 dummy 判断 l1 或 l2 哪个 head 小 小的 head 链接到dummy的end 然后小的 head 往后推 123456789101112131415161718192021222324252627282930313233/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; ListNode dummy = new ListNode(0); ListNode end = dummy; while(l1!=null &amp;&amp; l2!=null)&#123; if(l1.val &lt; l2.val)&#123; end.next = l1; l1 = l1.next; &#125;else&#123; end.next = l2; l2 = l2.next; &#125; end = end.next; &#125; //l1先用完了 if(l1==null)&#123; end.next = l2; &#125;else&#123; end.next = l1; &#125; return dummy.next; &#125;&#125; 融合2个有序数组 Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array. Note:You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. The number of elements initialized in nums1 and nums2 are m and n respectively. 与上面链表类似，用nums1末端多余的空位做dummy，比较nums1和nums2末端最大值，取大值填入dummy。 因为index = n+m-1，dummy在向前推进的过程中，nums1有效数据也在前进，nums1中有效数据恰巧永远不会被后面添加进来的值覆盖 123456789101112131415161718192021class Solution &#123; public void merge(int[] nums1, int m, int[] nums2, int n) &#123; int i = m-1; int j = n-1; int index = m+n-1; while (i&gt;=0 &amp;&amp; j&gt;=0)&#123; if (nums1[i] &gt; nums2[j])&#123; nums1[index--] = nums1[i--]; &#125;else&#123; nums1[index--] = nums2[j--]; &#125; &#125; //如果nums2有剩余 while(j&gt;=0)&#123; nums1[index--] = nums2[j--]; &#125; //如果nums1有剩余，则不需要改动。 &#125;&#125; 判断回文链表 龟兔赛跑算法求中间节点 将后半段反转得 l2 若l2与原链表重合则是回文 无论链表长度奇偶，前半段会多余1或2个节点，但只要保证反转后的后半段l2遍历完则可证明回文 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public boolean isPalindrome(ListNode head) &#123; ListNode mid = findMiddle(head); ListNode l2 = reverse(mid); while(head!=null &amp;&amp; l2 !=null &amp;&amp; head.val==l2.val)&#123; head = head.next; l2 = l2.next; &#125; return l2==null; &#125; public ListNode findMiddle(ListNode head)&#123; ListNode slow = head; ListNode fast = head; while(fast!=null)&#123; slow = slow.next; fast = fast.next; if(fast!=null)&#123; fast = fast.next; &#125; &#125; return slow; &#125; public ListNode reverse(ListNode head)&#123; ListNode dummy = new ListNode(0); ListNode prev = null; while(head!=null)&#123; //因为条件是head!=null,所以可以放心地取head.next ListNode tmp = head.next; head.next = prev; prev = head; head = tmp; &#125; return prev; &#125;&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Scrapy 的一些配置]]></title>
    <url>%2F2018%2F02%2F21%2Fcjficuhd6001ke3lvgp4thpy4%2F</url>
    <content type="text"><![CDATA[增加并发并发是指同时处理的request的数量。其有全局限制和局部(每个网站)的限制。Scrapy默认的全局并发限制对同时爬取大量网站的情况并不适用，因此您需要增加这个值。 增加多少取决于您的爬虫能占用多少CPU。 一般开始可以设置为 100 。不过最好的方式是做一些测试，获得Scrapy进程占取CPU与并发数的关系。 为了优化性能，您应该选择一个能使CPU占用率在80%-90%的并发数在setting.py文件中写上CONCURRENT_REQUESTS = 100，scrapy中默认的并发数是32 降低log级别当进行通用爬取时，一般您所注意的仅仅是爬取的速率以及遇到的错误。 Scrapy使用 INFO log级别来报告这些信息。为了减少CPU使用率(及记录log存储的要求), 在生产环境中进行通用爬取时您不应该使用 DEBUG log级别。 不过在开发的时候使用 DEBUG 应该还能接受。setting.py文件中设置LOG_LEVEL = &#39;INFO&#39; 禁止cookies除非您 真的 需要，否则请禁止cookies。在进行通用爬取时cookies并不需要， (搜索引擎则忽略cookies)。禁止cookies能减少CPU使用率及Scrapy爬虫在内存中记录的踪迹，提高性能。COOKIES_ENABLED = False 禁止重试对失败的HTTP请求进行重试会减慢爬取的效率，尤其是当站点响应很慢(甚至失败)时， 访问这样的站点会造成超时并重试多次。这是不必要的，同时也占用了爬虫爬取其他站点的能力。 RETRY_ENABLED = False 减少下载超时如果您对一个非常慢的连接进行爬取(一般对通用爬虫来说并不重要)， 减小下载超时能让卡住的连接能被快速的放弃并解放处理其他站点的能力。 DOWNLOAD_TIMEOUT = 15,其中15是设置的下载超时时间 禁止重定向除非您对跟进重定向感兴趣，否则请考虑关闭重定向。 当进行通用爬取时，一般的做法是保存重定向的地址，并在之后的爬取进行解析。 这保证了每批爬取的request数目在一定的数量， 否则重定向循环可能会导致爬虫在某个站点耗费过多资源。 REDIRECT_ENABLED = False 使用user_agent池TODO 使用ip代理池TODO 设置延迟DOWMLOAD_DELY=3,设置延迟下载可以避免被发现 启用调试工具命令行调试scrapy shell url 查看网页，不过这种方式可能对于要请求头的网页不行，对于一般的网页还是可以的 scrapy view shell 用来查看动态加载的网页，如果查看的网页用了动态加载，那么用这个命令行打开的网页就是不完整的，肯定缺少了什么 编辑器中的调试在页面的任意位置添加如下代码 123from scrapy.shell import inspect_responsedef paser(self,response): inspect_response(response,self) #当程序运行到这里就会跳出终端，并且在终端出现调试命令，当然这个可以随便写在哪里 暂停和恢复爬虫初学者最头疼的事情就是没有处理好异常，当爬虫爬到一半的时候突然因为错误而中断了，但是这时又不能从中断的地方开始继续爬，顿时感觉心里日了狗，但是这里有一个方法可以暂时的存储你爬的状态，当爬虫中断的时候继续打开后依然可以从中断的地方爬，不过虽说持久化可以有效的处理，但是要注意的是当使用cookie临时的模拟登录状态的时候要注意cookie的有效期 只需要在setting.py中JOB_DIR=file_name其中填的是你的文件目录，注意这里的目录不允许共享，只能存储单独的一个spdire的运行状态，如果你不想在从中断的地方开始运行，只需要将这个文件夹删除即可 当然还有其他的放法：scrapy crawl somespider -s JOBDIR=crawls/somespider-1，这个是在终端启动爬虫的时候调用的，可以通过ctr+c中断，恢复还是输入上面的命令 不按照robots.txt1ROBOTSTXT_OBEY = False 配置请求头只需要在settings中取消相应的设置即可 12345DEFAULT_REQUEST_HEADERS=&#123;&#123; &apos;Accept&apos;: &apos;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&apos;, &apos;Accept-Language&apos;: &apos;en&apos;, &apos;User-Agent&apos;:&apos;......&apos; #在此处设置&#125;&#125;]]></content>
      <tags>
        <tag>Python</tag>
        <tag>Scrapy</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 数组与字符串笔记]]></title>
    <url>%2F2018%2F02%2F21%2Fcjficuhc2000he3lv3sje5uwr%2F</url>
    <content type="text"><![CDATA[Python 统计列表中出现数字次数coll = collections.Counter(nums1) 矩阵旋转 先求转置，再水平翻转，也可先按另一条对角线反转，再垂直翻转 12345678910111213141516171819202122232425262728293031323334353637383940Python:class Solution: def rotate(self, matrix): &quot;&quot;&quot; :type matrix: List[List[int]] :rtype: void Do not return anything, modify matrix in-place instead. &quot;&quot;&quot; n = len(matrix) for i in range(n): for j in range(n-i): matrix[i][j], matrix[n-1-j][n-1-i] = matrix[n-1-j][n-1-i], matrix[i][j] matrix.reverse()---JAVA:class Solution &#123; public void rotate(int[][] matrix) &#123; int n = matrix.length; for(int r=0;r&lt;n;r++) &#123; for(int c=0;c&lt;n-r;c++) &#123; int tmp = matrix[r][c]; matrix[r][c] = matrix[n-1-c][n-1-r]; matrix[n-1-c][n-1-r] = tmp; &#125; &#125; for(int r=0;r&lt;n/2;r++) &#123; for(int c=0;c&lt;n;c++) &#123; int tmp = matrix[r][c]; matrix[r][c] = matrix[n-1-r][c]; matrix[n-1-r][c] = tmp; &#125; &#125; &#125;&#125; 直接计算4个方向的相对位置并交换 123456789101112131415161718class Solution &#123; public void rotate(int[][] matrix) &#123; int n = matrix.length; for(int r=0;r&lt;(n+1)/2;r++) &#123; for(int c=0;c&lt;n/2;c++) &#123; int tmp = matrix[r][c]; matrix[r][c] = matrix[n-1-c][r]; matrix[n-1-c][r] = matrix[n-1-r][n-1-c]; matrix[n-1-r][n-1-c] = matrix[c][n-1-r]; matrix[c][n-1-r] = tmp; &#125; &#125; &#125;&#125; 判断数字合法性打表建立 现状-输入-结果模型 123456789101112131415161718192021222324252627282930class Solution: def isNumber(self, s): &quot;&quot;&quot; :type s: str :rtype: bool &quot;&quot;&quot; INVALID=0; DIGIT=1; DOT=2; EX=3; SPACE=4; SIGN=5 table = [ [-1, 1, 2, -1, 0, 3], #0 开始或只有空格 [-1, 1, 4, 5, 6, -1], #1 只有数字 [-1, 4, -1, -1, -1, -1], #2 只有点 [-1, 1, 2, -1, -1, -1], #3 只有符号 [-1, 4, -1, 5, 6, -1], #4 用了数字和点 [-1, 7, -1, -1, -1, 8], #5 数字接了e [-1, -1, -1, -1, 6, -1], #6 以空格正常结尾了 [-1, 7, -1, -1, 6, -1], #7 e后面接了数字 [-1, 7, -1, -1, -1, -1], #8 e后面接了符号 ] state = 0; i = 0; for i in s: input_type = INVALID if i in &apos;1234567890&apos;: input_type = 1 if i == &apos;.&apos;: input_type = 2 if i == &apos;e&apos; or i == &apos;E&apos;: input_type = 3 if i == &apos; &apos;: input_type = 4 if i == &apos;-&apos; or i == &apos;+&apos;: input_type = 5 state = table[state][input_type] if state == -1: return False return state in [1,4,6,7] #只有这些是合法的]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[半夜惊现 Apache 未关闭目录浏览功能]]></title>
    <url>%2F2018%2F02%2F06%2Fcjficuhed003ye3lvko9ns5jq%2F</url>
    <content type="text"><![CDATA[问题深夜突然发现，自己的网站惊现了类似以下场景： 根据常识这是没有关闭 Apache 的目录浏览功能，在非必要情况下是不安全的。 遂做以下操作： 步骤打开配置文件12345[root@vultr myblog]# cd /etc/httpd/conf/[root@vultr conf]# lshttpd.conf magic[root@vultr conf]# vi httpd.conf[root@vultr conf]# 修改配置文件123456&lt;Directory &gt; # Options Indexes FollowSymLinks Options FollowSymLinks&lt;/Directory&gt; 重启 Apache1[root@vultr conf]# systemctl restart httpd 效果配置成功后再访问目录被拒绝，完成。 TODO [] 熟悉更多 Apache 配置]]></content>
      <tags>
        <tag>Apache</tag>
        <tag>服务器安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[彻底搞清楚 Unicode 和 UTF-8]]></title>
    <url>%2F2018%2F02%2F05%2Fcjficuhe3003be3lvhgl8qjdw%2F</url>
    <content type="text"><![CDATA[概括Unicode： 统一长度，方便程序在内存中处理。UTF-8： 优化长度，方便网络传输，文件存储。 encode(): Unicode转为 UTF-8的过程。decode(): UTF-8 转为 Unicode 的过程。 例子已知：汉字“我”的编码为： 编码类型 编码值 Unicode u’\u6211’ UTF-8 \xe6\x88\x91 Python2Python2中的字符串有两种类型： str windows 默认编码：GB2132 （待更新） Unix 默认编码： UTF-8 Unicode 在 Python 终端测试： 在 Unix 中定义为 str 类型 1234567891011&gt;&gt;&gt; s = &quot;我&quot;&gt;&gt;&gt; s&apos;\xe6\x88\x91&apos; #编码为UTF-8&gt;&gt;&gt; type(s)&lt;type &apos;str&apos;&gt; # 类型为 str&gt;&gt;&gt;&gt;&gt;&gt; s.decode(&quot;UTF-8&quot;) #转化为 Unicode，参数指明当前是UTF-8u&apos;\u6211&apos;&gt;&gt;&gt;&gt;&gt;&gt; s.decode(&quot;UTF-8&quot;).encode(&quot;UTF-8&quot;)&apos;\xe6\x88\x91&apos; # 将 Unicode 再转为 UTF-8 在 Unix 中定义为 Unicode 类型 123456789&gt;&gt;&gt; s = u&quot;我&quot;&gt;&gt;&gt; su&apos;\u6211&apos; # 编码为 Unicode&gt;&gt;&gt;&gt;&gt;&gt; type(s)&lt;type &apos;Unicode&apos;&gt; # 类型为 Unicode&gt;&gt;&gt;&gt;&gt;&gt; s.encode(&quot;UTF-8&quot;)&apos;\xe6\x88\x91&apos; # 可以直接转为 UTF-8 文件运行测试：codeTest.py: (不声明编码) 12s = &quot;我&quot;print s 运行文件： 123❯ python codeTest.py File &quot;codeTest.py&quot;, line 1SyntaxError: Non-ASCII character &apos;\xe6&apos; in file codeTest.py on line 1, but no encoding declared; see http://python.org/dev/peps/pep-0263/ for details codeTest.py:(声明UTF-8) 123# -*-coding=UTF-8-*-s = &quot;我&quot;print s 运行文件： 12❯ python codeTest.py我 Python3Python3 中的字符串只有一种类型： str，且统一为 Unicode 编码。 在 Python 终端测试：123456789101112&gt;&gt;&gt; s = &quot;我&quot;&gt;&gt;&gt; type(s)&lt;class &apos;str&apos;&gt; # 类型为 str&gt;&gt;&gt;&gt;&gt;&gt; s = u&quot;我&quot;&gt;&gt;&gt; type(s)&lt;class &apos;str&apos;&gt; # 类型也为 str&gt;&gt;&gt;&gt;&gt;&gt; s&apos;我&apos;&gt;&gt;&gt; s.encode(&quot;UTF-8&quot;) # 可以直接 encode 为 UTF-8b&apos;\xe6\x88\x91&apos; 文件运行测试：codeTest.py: (不声明编码) 12s = u&quot;我&quot;print(s) 运行文件： 12❯ python3 codeTest.py我 待更新： [ ] 在 windows 中的 str 测试 [ ] 调用 encode()前会先按内置编码(sys.defaultcoding()查看) 进行 decode() [ ] json.dumps过程中的处理问题 [ ] byte 字节码的转换 [ ] requests 库返回的 Response 对象中编码问题 [ ] 文档本身的编码和以上并非同一问题（如中文注释出现乱码）。]]></content>
      <tags>
        <tag>Python</tag>
        <tag>编码</tag>
        <tag>Unicode</tag>
        <tag>UTF-8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[虚拟环境 Venv 的使用]]></title>
    <url>%2F2018%2F02%2F02%2Fcjficuheg0043e3lvdvxgvvyf%2F</url>
    <content type="text"><![CDATA[以前是一直懒得使用所谓的虚拟环境的，需要什么就用 pip 一股脑往里装就行了。 新版本的 Pycharm 在新建项目时提供了创建 venv 的选项，方便了不少。于是学习使用了下，但最后还是使用命令行操作了。 新建虚拟环境1❯ python3 -m venv project_name 会在当前目录下创建项目，里面包含三个文件夹，bin，lib，和include 如果项目已经存在了，可以： 1❯ python3 -m venv . .代表当前目录 ps： venv 会自带 pip，在必要时可以添加额外参数 --without-pip ，然后再手动安装 pip。 激活虚拟环境在 cd到创建的虚拟环境之后，执行 bin 下的 activate： 1❯ source bin/activate 激活后命令行前面会有 带括弧的虚拟环境名称： 1234❯ source bin/activateArticleSpider git/master*(ArticleSpider) ❯ 此时使用 pip 安装依赖包就会装到此目录的lib文件夹里。 退出虚拟环境1❯ deactivate 问题环境创建好后就不能直接移动文件夹的位置了，否则启动环境等各种命令会出错，在bin/activate 中配置了虚拟环境所在路径，修改为移动后路径可以启动并运行项目，但仍有隐患。 似乎存在正确移动方法，待学习。]]></content>
      <tags>
        <tag>venv</tag>
        <tag>Pythonh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Selenium 的使用]]></title>
    <url>%2F2018%2F02%2F02%2Fcjficuhd1001he3lvxszn871q%2F</url>
    <content type="text"><![CDATA[Selenium 支持各大浏览器, 进行自动化测试。在爬虫中主要是模拟浏览器的行为，目前为止我用 Selenium 主要用于： 模拟登录并获取 Cookie 在动态加载的网页中执行 js ，获取更多内容 创建并启动浏览器支持多种浏览器，包括 PhantomJs 12345678910from selenium import webdriver# 可能需要提供执行文件路径browser = webdriver.Chrome(executable_path=&apos;/Users/eeljiang/chromedriver&apos;)# browser = webdriver.Firefox()# browser = webdriver.Safari()# browser = webdriver.PhantomJs()browser.get(&apos;http://www.baidu.com&apos;)print(browser.page_source) 保存 Cookies12345678910111213141516import picklecookie_dict = &#123;&#125;Cookies = browser.get_cookies()# print(Cookies)# with open(&apos;/Users/eeljiang/Desktop/zhihuCookies&apos;, &apos;wb&apos;) as f: for cookie in Cookies: # 只取了 name 和 value 两个键 cookie_dict[cookie[&apos;name&apos;]] = cookie[&apos;value&apos;] # 保存到文件，供后续读取 pickle.dump(cookie_dict, f) # with open(&apos;/Users/eeljiang/Desktop/zhihuCookies&apos;, &apos;rb&apos;) as f:# cookie_dict = pickle.load(f) 可以对网页中的元素进行操作1234# 选取元素 填写表单browser.find_element_by_css_selector(&quot;#loginname&quot;).send_keys(&quot;159xxxxxxxx&quot;)browser.find_element_by_css_selector(&quot;.info_list.password input[name=&apos;password&apos;]&quot;).send_keys(&quot;password&quot;)browser.find_element_by_css_selector(&quot;.info_list.login_btn a[node-type=&apos;submitBtn&apos;]&quot;).click() 有时触发了账号异常，需要模拟按一下 ESC 关掉弹出的验证框1234567from selenium.webdriver.common.action_chains import ActionChainsfrom selenium.webdriver.common.keys import Keys# 可以定义一串操作，最后一起perform()actions = ActionChains(browser)actions.send_keys(Keys.ESCAPE)actions.perform() 执行 js1234# 将页面滚动到最低端三次，完成 ‘加载更多’ 操作for i in range(3): browser.execute_script(&quot;window.scrollTo(0, document.body.scrollHeight); var lenOfPage=document.body.scrollHeight; return lenOfPage;&quot;) time.sleep(1) 不加载图片必要时可以设置不加载图片的选项，加快执行速度 123456# chrome 不加载图片chrome_opt = webdriver.ChromeOptions()prefs = &#123;&quot;profile.managed_default_content_settings.images&quot;: 2&#125;chrome_opt.add_experimental_option(&quot;prefs&quot;, prefs)# 在创建浏览器前设置，并在创建时额外提供参数即可browser = webdriver.Chrome(chrome_options=chrome_opt) 无窗口运行PhantomJS 是无界面的，但是并发性能很差。在 Linux 中， Chrome 可以无界面运行 123456# 依赖 pyvirtualdisplay 和 xvfbfrom pyvirtualdisplay import Displaydisplay = Display(visible=0, size=(800, 600))display.start()# 然后再运行 Chrome 即隐藏窗口browser = webdriver.Chrome() 退出任务完成后记得退出浏览器，尤其在无界面环境时 1browser.quit()]]></content>
      <tags>
        <tag>Python</tag>
        <tag>Selenium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL 授权远程连接]]></title>
    <url>%2F2018%2F02%2F01%2Fcjficuhdi0021e3lvvjns44iw%2F</url>
    <content type="text"><![CDATA[新服务器上的 MySQL 需要从本地复制一些数据库表.为了让本地的 Navicat 能连接到服务器的 MySQL, 需要在服务器上修改一下权限. 123mysql&gt; use mysql;Database changedmysql&gt; grant all privileges on *.* to root@&apos;%&apos; identified by &quot;passwd&quot;; 然后刷新一下权限 1mysql&gt;flush privileges ; 其中 ,% 代表所有的 host. 12345678910mysql&gt; select host,user,password from user;+--------------+------+-------------------------------------------+| host | user | password |+--------------+------+-------------------------------------------+| localhost | root | *A731AEBFB621E354CD41BAF207D884A609E81F5E || 192.168.1.1 | root | *A731AEBFB621E354CD41BAF207D884A609E81F5E || % | root | *A731AEBFB621E354CD41BAF207D884A609E81F5E |+--------------+------+-------------------------------------------+3 rows in set (0.00 sec) 取消授权的时候偷了个懒,直接把记录删掉就好了. 12mysql&gt; delete from user where user=&apos; root&apos; and host=&apos;%&apos; ;mysql&gt;flush privileges ; 另外，如果是新安装的 MySQL，可能需要修改一下配置文件 1root@iZ28v2kfotyZ:~# vi /etc/mysql/my.cnf 在 my.cnf 中，将默认的 只允许本地连接注释掉，然后重启 Linux。 1234# Instead of skip-networking the default is now to listen only on# localhost which is more compatible and is not less secure.#bind-address = 127.0.0.1]]></content>
      <tags>
        <tag>MySQL -</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[区块链技术学习指引]]></title>
    <url>%2F2018%2F01%2F12%2Fcjficuhe5003ee3lvrd89g438%2F</url>
    <content type="text"><![CDATA[本文作者： Tiny熊本文链接： https://learnblockchain.cn/2018/01/11/guide/版权声明： 本文采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！ 原本这篇文章是在我的wiki里，发现好多同学还是找不到，那就重新发一下。本文会一直更新，建议感兴趣的同学加入收藏夹。 引言给迷失在如何学习区块链技术的同学一个指引，区块链技术是随比特币诞生，因此要搞明白区块链技术，应该先了解下比特币。但区块链技术不单应用于比特币，还有非常多的现实应用场景，想做区块链应用开发，可进一步阅读以太坊系列。 比特币如果你是还不知比特币是什么，那就看看比特币是什么 基础入门接下来可以通过下面这几篇文章了解比特币大概的运行原理： 区块链记账原理通过这篇可以了解到区块链是一个怎样的结构比特币所有权及隐私问题通过这篇可以了解到地址私钥 非对称加密应用 等概念比特币如何挖矿通过这篇了解工作量证明比特币如何达成共识 - 最长链的选择通过这篇可以了解共识机制。 进阶在基础入门之后，可以进一步阅读以下几篇，理解分布式网络，交易验证。 分析比特币网络：一种去中心化、点对点的网络架构比特币区块结构 Merkle 树及简单支付验证分析比特币脚本及交易分析 - 智能合约雏形看完上面这些，区块链应该理解差不多了，就可以尝试实现一个简单的区块链了。参考这篇用Python从零开始创建区块链。 以太坊一个技术要落地还得靠应用， 以太坊就这样一个建立在区块链技术之上， 去中心化的应用平台。可以阅读几下几篇，这部分以开发为主，需要大家多发时间实践。 以太坊开发入门智能合约开发环境搭建及Hello World合约以太坊客户端Geth命令用法-参数详解Geth控制台使用实战及Web3.js使用 智能合约开发一步步教你开发、部署第一个Dapp应用一步步教你创建自己的数字货币（代币）进行ICO实现一个可管理、增发、兑换、冻结等高级功能的代币 深入浅出区块链 - 系统学习区块链，打造最好的区块链技术博客。 本文作者： Tiny熊本文链接： https://learnblockchain.cn/2018/01/11/guide/版权声明： 本文采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！]]></content>
      <tags>
        <tag>区块链</tag>
        <tag>比特币</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 学习之Self，cls，staticmethod，classmethod]]></title>
    <url>%2F2017%2F12%2F27%2Fcjficuhcr000ze3lvrdzcwp7y%2F</url>
    <content type="text"><![CDATA[总体说明python类的方法有三种： 通过def定义的，普通的一般的，需要至少传递一个参数，一般用self，这样的方法必须通过一个类的实例去访问，类似于 c++ 中通过对象去访问 在 def 前面加上@classmethod，这种类方法的一个特点就是可以通过类名去调用，但是也必须传递一个参数，一般用cls表示 class，表示可以通过类直接调用 在def前面加上@staticmethod，这种类方法是静态的类方法，类似于 c++ 的静态函数，他的一个特点是参数可以为空，同样支持类名和对象两种调用方式 普通的方法，第一个参数需要是self，它表示一个具体的实例本身 如果用了staticmethod，那么就可以无视这个self，而将这个方法当成一个普通的函数使用 而对于classmethod，它的第一个参数不是 self，是cls，它表示这个类本身 1234567891011121314151617181920212223&gt;&gt;&gt; class A(object): def foo1(self): print &quot;Hello&quot;,self @staticmethod def foo2(): print &quot;hello&quot; @classmethod def foo3(cls): print &quot;hello&quot;,cls &gt;&gt;&gt; a = A()&gt;&gt;&gt; a.foo1() #最常见的调用方式，但与下面的方式相同Hello &lt;__main__.A object at 0x9f6abec&gt;&gt;&gt;&gt; A.foo1(a) #这里传入实例a，相当于普通方法的selfHello &lt;__main__.A object at 0x9f6abec&gt;&gt;&gt;&gt; A.foo2() #这里，由于静态方法没有参数，故可以不传东西hello&gt;&gt;&gt; A.foo3() #这里，由于是类方法，因此，它的第一个参数为类本身。hello &lt;class &apos;__main__.A&apos;&gt;&gt;&gt;&gt; A #可以看到，直接输入A，与上面那种调用返回同样的信息。&lt;class &apos;__main__.A&apos;&gt; 深入理解其实 self，cls 不是关键字，例如: 123456789101112131415161718192021class A: member = &quot;this is a test.&quot; def __init__(self): pass @classmethod def Print1(cls): print (&quot;print 1: &quot;, cls.member) def Print2(self): print (&quot;print 2: &quot;, self.member) @classmethod def Print3(paraTest): print (&quot;print 3: &quot;, paraTest.member) a = A()A.Print1() #相当于Print1(A)a.Print2() #相当于Print2(a)， 请注意@classmethodA.Print3() 输出： 1234print 1: this is a test.print 2: this is a test.print 3: this is a test.[Finished in 0.1s] 可以看出来，Python 在通过 “.” 调用成员函数的时候，会将 “.” 前面的东西当作函数的第一个参数调用。而且 Pyhon 并不关心我们把类的成员函数的第一个参数的名称是什么，我们可以用任意的名称，可以看Print3的定义就知道了。 原文链接：python学习之self, cls, staticmethod, classmethod 更新：2018-3-21 22:50之前虽然知道怎么使用，但分不清 @classmethod 和 @staticmethod 的具体使用场景有什么差异，似乎都可以用A.func()来调用。今天看到了这个2000赞的答案恍然大悟。Meaning of @classmethod and @staticmethod for beginner? 2018-3-22 13:54同时，这三类方法都是能被子类继承的]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2017%2F12%2F25%2Fcjficuhe7003ke3lv4cwqtn2j%2F</url>
    <content type="text"><![CDATA[正则表达式 括号分组以左括排序 贪婪匹配 是从右向左匹配的 [^1]：不是1 \s：空格 ， \S：非空格 [\u4E00-\u9FA5] 汉字 \w = [a-zA-z0-9_]; \W：不是\w 爬虫url去重bitmapbloomfilter 字符串编码unicode：2字节16位ASCII 在 unicode 中：高8位补零utf-8：英文1字节，汉字3字节，生僻字：4-6字节 编程、内存中：使用固定长度的unicode网络传输、文件保存：utf-8encode 是 unicode =&gt; utf-8/gb2132 以保存传输decode 是 utf-8/gb2132 =&gt; unicode 以显示 linux: utf-8windows:gb2132 python2： 调用.encode()的必须是 unicodepython3: 默认 unicode,字符串可以直接 encode 成 utf-8]]></content>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 迭代器和生成器]]></title>
    <url>%2F2017%2F12%2F24%2Fcjficuhcu0016e3lvm3et107h%2F</url>
    <content type="text"><![CDATA[全文转载自Hom’s Blog 可迭代对象 Iterable凡是可以用作for循环的都是可迭代对象,包括一般的list,tuple,set,dict,迭代器和生成器(或生成器函数)等. 可迭代对象具有__iter__方法返回迭代器. 可迭代对象可以通过iter(obj)生成迭代器(本质调用__iter__方法). 可迭代对象本质是数据流,一个接一个的数据,但不一定像迭代器和生成器一样记住迭代到那个点, 下一个是什么, 利用iter()函数可以将list等转变为迭代器(其实是生成器), 逐个元素投出. 可以通过isinstance(obj, Iterable) (需要事先from collections import Iterable)来判断对象是否可迭代对象. 迭代器 Iterator凡是可以通过next()方法返回下一个值的可迭代对象就是迭代器. 生成器是一种迭代器.enumurate也是迭代器(本质生成器) 可以通过isinstance(obj, Iterator) (需要事先from collections import Iterable) 来判断对象是否迭代器. 迭代到没有值了返回StopIteration错误. 迭代器拥有__iter__方法和__next__方法,有时隐藏掉(如生产器).但本质具备该两种方法.__iter__方法返回迭代且对象本身, 而next方法则调用下一个元素. 在自定义迭代器时需要定义该两种方法.for循环本质是通过调用可迭代对象的__iter__方法获取迭代器对象,再用next方法遍历元素. 可迭代对象和迭代器的分开自定义分开定义的好处在于, 当对可迭代对象使用iter()转变时,返回一个新的迭代器对象, 这时不受先前产生的相应迭代器对象影响. 123456789101112131415161718192021222324252627282930313233343536373839class Zrange: def __init__(self, n): self.n = n def __iter__(self): return ZrangeIterator(self.n)class ZrangeIterator: def __init__(self, n): self.i = 0 self.n = n def __iter__(self): return self def next(self): if self.i &lt; self.n: i = self.i self.i += 1 return i else: raise StopIteration() zrange = Zrange(3)print zrange is iter(zrange) #&gt;&gt;&gt; True print [i for i in zrange]#&gt;&gt;&gt;[1,2,3]print [i for i in zrange]#&gt;&gt;&gt;[1,2,3]# 若不区分可迭代对象和迭代器, 即这里列表生成式中使用ZrangeIterator的话, # 第二次调用时迭代器已被迭代完,第二次会为空集.zzrange=ZrangeIterator(3);print [i for i in zzrange]#&gt;&gt;&gt;[1,2,3]print [i for i in zzrange]#&gt;&gt;&gt;[] generator生成器对象生成器通过生成器函数产生, 生成器函数可以通过常规的def语句来定义, 不用return而是使用yield一次返回一个结果, 返回后停在相应位置, 再次调用时继续执行生成下一个结果, 当生成器结束没有下次执行时, 返回StopIteration. (x for x in range(10))该表达式产生的是生成器对象,而非列表. 生成器有close()方法,可以关闭生成器. 另有send(obj)方法,定义yield表达式执行后返回的值. 如val=yield i,正常情况下用next返回的值为None,所以send(None)和next()等价.也可以另外赋值,从而追踪某些情况.另外注意send第一次使用要在执行过yield以后(即最少一次执行迭代)才能使用,否则没有yield的返回值可以定义就会报错. 123456789101112131415# 生成器函数def fib(max): n, a, b = 0, 0, 1 while n &lt; max: #生成器关键一步yield,每次执行到此返回,下次从此开始. yield b a, b = b, a + b n = n + 1# 通过生成器函数产生生成器对象g=fib(6);# 单独调用生成器对象print g.next();# 利用循环迭代生成器for i in g: print i list等的迭代器.将list/dict等转化为迭代器使用iter(obj)函数. i.next()方法或next(i) 函数遍历迭代器 enumerate(i) 通过iter()函数将list/dict等数据组组转为迭代器.创建一个列表迭代器(listiterator)123456789101112131415i1 = iter([1, 2, 3]) # iter是Python BIF，用于生成迭代器，文档见底部type(i1)&lt;type &apos;listiterator&apos;&gt;i1&lt;listiterator object at 0x1cedf50&gt;# 创建一个字典项迭代器(dictionary-itemiterator)d = dict(a = 1, b = 2)i2 = d.iteritems() # 生成iterator对象，对于字典来说还有iterkeys, itervalues等方法可用i2&lt;dictionary-itemiterator object at 0x1dfe208&gt;[e for e in d.iteritems()] # dict.iteritems方法生成的是迭代器元素为键值对形式[(&apos;a&apos;, 1), (&apos;b&apos;, 2)]# 另外还有tuple/set等都可使用iter函数返回iterator对象 步进式访问迭代器中元素obj.next() 1234567891011i = iter(range[3])i.next()0i.next()1next(i) # next() - python2.6新增BIF，作用同iterator.next()2next(i) # 无元素可迭代时，抛出StopIteration异常，可以通过捕获此异常判断是否迭代完毕Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;StopIteration 循环访问遍历迭代器：手动循环1234567891011try: while True: next(i) # python2.6之前版本使用iterator.next()方法except StopIteration: print &apos;Done&apos;# for循环&gt;&gt;&gt; i = iter(range(3))# 以下句法叫做列表解析，这与生成器表达式类似，之后文章介绍生成器时再记&gt;&gt;&gt; [e for e in i] # for在这里不断调用next函数，直到捕获StopIteration异常后退出[0, 1, 2] 将迭代器传递给其他函数使用：12&gt;&gt;&gt; list(iter(range(3)))[0, 1, 2] 帮助迭代器实现索引功能：使用enumerate函数返回一个迭代器对象, 该对象能够生产一个元组包括(索引,值). 1enumerate(iterable, start=0) 第一参数是可迭代对象包括list/dict/迭代器等, 第二个参数是索引开始的号. 123&gt;&gt;&gt; i = iter(&apos;abc&apos;) # python中字符串也是可迭代对象&gt;&gt;&gt; [(k, v) for k, v in enumerate(i)] # enumerate返回一个元素为tuple的iterator，文档见底部[(0, &apos;a&apos;), (1, &apos;b&apos;), (2, &apos;c&apos;)]]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Scrapy的第一次使用]]></title>
    <url>%2F2017%2F12%2F15%2Fcjficuhel004ce3lvz0z1xnxl%2F</url>
    <content type="text"><![CDATA[新建Scrapy脚本使用Selector xpath() 选择器提取数据配置 Item 和 pipelinespymysql写入数据库]]></content>
      <tags>
        <tag>Python</tag>
        <tag>Scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python学习手册记录]]></title>
    <url>%2F2017%2F12%2F14%2Fcjficuhdh001ze3lvha2ixrnc%2F</url>
    <content type="text"><![CDATA[.pyc 字节码的保存 import就会生成 dir(S) 字典的排序输出 for I in sort(L) Floor 除法 x//y 保留整数 repr() 取得对象原始内容 浮点数 与 小数对象 0.1+0.1+0.1-0.3 使用切片或cop()拷贝对象而非引用 print(i,end=’,’),默认end=换行7- 使用整数作为字典的键 稀疏数据结构 c = sorted(c) 支持包括tulpe的排序 标准库pickle模块 存储任何格式的对象 无值分片和字典copy只能做顶层复制，深层嵌套拷贝需要import copy 调用函数时:号将元组解包成序列,将字典解包成 k=v; 定义函数中:打包成元组,**打包成字典 使用工厂函数(函数的嵌套)保存状态信息 函数注解 def func(a:’spam’=4, b:(1,10)=5)-&gt;int fun.annotations 返回注解字典 模块的循环导入 （代办） except: 为空会捕捉所有异常，包括KeyboardInterrupt。为排除系统错误，至少要 except Exception as e:]]></content>
  </entry>
  <entry>
    <title><![CDATA[Python对数据的典型操作]]></title>
    <url>%2F2017%2F12%2F13%2Fcjficuhcs0012e3lvt4e0iwnv%2F</url>
    <content type="text"><![CDATA[涉及操作 Excel文档读写(Workbook、load_workbook) 字符串处理 MySQL写入(pymysql) 细节 迭代器 I.next() 字符串 strip 去空格 字符串 split 分割 isinstance(data,str) 判断实例类型 ‘o’ in ‘boom’ 字符串中包含… 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889from openpyxl import Workbookfrom openpyxl import load_workbookimport pymysql.cursorscontents = []def readexcel(path): # load工作簿 wb = load_workbook(path) # get工作表名称 sheets = wb.get_sheet_names() # get第一张工作表名称 sheet0 = sheets[0] # 工作表对象 worksheet = wb.get_sheet_by_name(sheet0) # 所有行对象 可迭代 rows = worksheet.rows # 手动迭代 I = iter(rows) for row in I: # 获取该行第一列值，空白则返回None data = row[0].value # 并过滤无效行 if data and (&apos;种）&apos; not in data): # ISSN号被分在了下一行 while &quot;ISSN&quot; not in data: # 迭代到下一行的数据，并取值 value = I.__next__()[0].value if value and (&apos;种）&apos; not in value): data += value print(data) try: # 将名称与号码分割并去掉空白，再插入contents # contents.append([data.split(&quot;ISSN&quot;)[0].strip(), data.split(&quot;ISSN&quot;)[1].strip()]) # 感觉用下面的更好看 contents.append([item.strip() for item in data.split(&quot;ISSN&quot;)]) except: print(&quot;wrong!&quot;)def writeexcel(path, value): # 创簿 wb = Workbook() # 创表 sheet = wb.create_sheet(&quot;测试表&quot;) for i in range(len(value)): for j in range(2): sheet.cell(row=i+1, column=j+1).value = value[i][j] wb.save(path) print(&quot;xslx done！&quot;)def db(): connection = pymysql.connect(host=&apos;127.0.0.1&apos;, port=3306, user=&apos;root&apos;, password=&apos;123&apos;, db=&apos;academic&apos;, charset=&apos;utf8mb4&apos;, cursorclass=pymysql.cursors.DictCursor ) for content in contents: try: with connection.cursor() as cursor: # 执行sql语句，插入记录 sql = &apos;INSERT INTO crawl_data_periodicals (name, issn_number) VALUES ( %s, %s)&apos; cursor.execute(sql, (content[1], content[0])) # 没有设置默认自动提交，需要主动提交，以保存所执行的语句 connection.commit() finally: connection.close() print(&quot;db done!&quot;)path=&quot;/Users/eeljiang/Desktop/工作簿1.xlsx&quot;readexcel(path)#writeexcel(&quot;result.xlsx&quot;,contents)# print(content)print(&quot;len:&quot;, len(contents))# db() 补充1isinstance(data, str) 上面代码其实只用 data 代替就好了因为我的目的只是判断data是不是为None，不需要限定str类型这可以称之为破坏了代码的灵活性，因为限定了它只能用一种类型工作 我们强调编写对象接口，而不是类型。]]></content>
      <tags>
        <tag>Python</tag>
        <tag>Excel</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flask-Migrate数据库迁移]]></title>
    <url>%2F2017%2F08%2F03%2Fcjficuhc6000me3lv5s3ibt21%2F</url>
    <content type="text"><![CDATA[在学习 Flask Web开发 一书的时候, 书上使用Flask-Migrate插件来管理数据库版本迁移。但是书本上的讲解较少,实际操作时遇到了错误。书本上使用的 sqlite 不支持对表的字段修改和删除, 不能用图形化工具直接修改字段,而使用数据库的版本控制时仍有问题 安装根据书本, 在成型的 flask 项目中的 manage.py 里已有如下配置。 1234567891011121314151617from app import create_app, dbfrom flask_script import Shell, Managerfrom flask_migrate import Migrate, MigrateCommandfrom app.models import User, Role # 数据库table类 app = create_app(os.getenv(&apos;FLASK_CONFIG&apos;) or &apos;default&apos;)manager = Manager(app)migreate = Migrate(app, db) def make_shell_context(): return dict(app=app, db=db, User=User, Role=Role) manager.add_command(&apos;shell&apos;, Shell(make_context=make_shell_context)) # 添加shell命令，默认引入make_shell_context()返回值中的modelmanager.add_command(&apos;db&apos;, MigrateCommand) #添加db命令，绑定MigrateCommand命令 if name == &apos;main&apos;: manager.run() 命令行中执行以安装插件pip install flask-migrate 初始化在命令行中执行命令以初始化(db 命令在 manage.py 中绑定)python manage.py db init此时需要保证并没有创建过数据库,否则会有如下报错alembic.util.exc.CommandError: Directory migrations already exists 初始化完成后,项目根目录下会生成一个migrations文件夹，这个文件夹就是我们的迁移版本库，其中包括一些配置文件，其中文件夹versions存放我们的版本迁移脚本。 生成迁移脚本脚本生成命令是python manage.py db migrate -m &quot;migration1&quot; 12345python hello.py db migrate -m &quot;first migration&quot;INFO [alembic.runtime.migration] Context impl SQLiteImpl.INFO [alembic.runtime.migration] Will assume non-transactional DDL.INFO [alembic.autogenerate.compare] Detected added column &apos;users.avatar_hash&apos;Generating /Users/eeljiang/Documents/PycharmProjects/FlaskLearning/migrations/versions/c0ce15b87acb_migration_1.py ... done 脚本创建完成后存放在./migrations/versions/目录下迁移脚本中有upgrade()和downgrade()函数，它们的作用分别是： upgrade()：将迁移中的改动应用到数据库中。 downgrade()：将迁移中的改动从数据库中删除，即具有回滚到某个迁移点的功能。 该步骤还会在数据库中生成 alembic_version表，该表作为 flask-migrateion 的迁移记录表。 升级数据库命令行中执行以将迁移中的改动( upgrade()) 应用到数据库中python manage.py db upgrade以下最后一行代码提示了版本号的迁移 123INFO [alembic.runtime.migration] Context impl SQLiteImpl.INFO [alembic.runtime.migration] Will assume non-transactional DDL.INFO [alembic.runtime.migration] Running upgrade 5ffc75b6132a -&gt; c0ce15b87acb, migration 1 滚回命令行中执行以将版本滚回至 5ffc75b6132a python hello.py db downgrade 5ffc75b6132a 常见报错alembic.util.exc.CommandError: Target database is not up to date. 多半是在迁移版本过程中版本号对不上了。在之前生成的alembic_version表中有一个version_num的字段，该字段存储了当前的数据库版本号，当遇到上述的报错信息时，可以查看一下这个字段中是否有信息，如果没有就将你需要存放的版本号手动填充进去，就可以正常的升级数据库了。 当然也可以直接删去./migrations/versions/中的版本数据，重新生成迁移脚本。 重要:upgrade或 downgrade 时若为 drop table或drop column时会报错, 应该和 sqlite 的特性有关。此时只能删了数据库重来,暂未解决。 参考链接Flask-Migrate数据库迁移插件学习小记Can’t migrate or upgrade database with Flask-Migrate (Alembic)]]></content>
      <tags>
        <tag>Python</tag>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用SSH Key登录并禁用root密码登录并修改端口号]]></title>
    <url>%2F2017%2F07%2F27%2Fcjficuhdx002ue3lv1i6ns2nr%2F</url>
    <content type="text"><![CDATA[使用密钥登录工作原理ssh除了使用密码验证外，还可以使用公私密钥的验证方式。客户端生成一个私钥和一个与之对应的公钥，然后将公钥上传到服务器上。 本地机器创建公钥ssh-keygen -t rsa -C &#39;your email&#39; 完成后生成如图两个文件,其中带pub结尾的是公钥,待会需要上传到服务器上保存 将公钥复制到ssh服务器将前一步骤生成的公钥~/id_rsa.pub文件，复制到ssh服务器对应用户下的~/.ssh/authorized_keys文件中。如果不存在则手动创建即可。 注意 当第二台设备生成公钥保存到此文件中时，请不要将之前的记录覆盖，应使用追加写入的方式。如： 1cat id_rsa.pub &gt;&gt; .ssh/authorized_keys 登录完成以上步骤后，即可使用以下命令直接登录ssh服务器。 1ssh username@hostname 自定义别名可以在~/.ssh/config中配置（未存在则新建即可） 1234Host yoyoyoHostName hostname #ssh服务器ip或域名User root #ssh服务器用户名IdentityFile id_rsa #生成的私钥 保存后即可使用以下命令快捷登录： 1ssh yoyoyo 禁用密码验证登录 在服务器上配置：/etc/ssh/sshd_config 找到下面一行PasswordAuthentication yes 将yes改为no后保存。 重启 sshd服务 关于密钥的生成:有教程是在服务器上生成，然后将密钥传回本地的。如果是服务器生成的话，切记将密钥传回本地后从服务器删除。因此我选择在本地生成密钥，后上传公钥的方法较为稳妥。 更改端口还是在/etc/ssh/sshd_config中，找到 port项目，取消注释并修改为较大的端口，可以防端口扫描。 返回到本地~/.ssh/config中，在之前的配置中增加 port 项和对应设置的端口： 12345Host yoyoyoHostName hostname #ssh服务器ip或域名Port 1234 #端口号User root #ssh服务器用户名IdentityFile id_rsa #生成的私钥 参考在Mac上远程登录VPSLinux配置使用SSH Key登录并禁用root密码登录 END]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>SSH</tag>
        <tag>安全防护</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Safari Bookmarklet 实现切换 Google 搜索结果的语言]]></title>
    <url>%2F2017%2F07%2F26%2Fcjficuhcv0019e3lvisd6qkce%2F</url>
    <content type="text"><![CDATA[背景Google 搜索的时候,常常遇到下面这样的情景:输入的关键词是若干个英文,如: safari stylish 由于输入的两个关键词都是英文单词, 且没有恰当的中文翻译, Google 默认给出的结果是英文结果优先, 而英文结果过多以至于掩盖中文结果。 产生以上困扰的原因是我的英语水平处于勉强能看懂英文但较为吃力的水平，因此一般只有在没有满意的中文结果时才去翻看英文结果。 当然可以通过点击工具-&gt;不限语言-&gt;中文网页的方式切换成中文,需要英文时再点清除恢复默认搜索语言但是要左点一下右点一下太麻烦了。 步骤JavaScript 代码:1javascript:void(function()&#123;if(location.hostname.indexOf(&quot;google&quot;))&#123;var keyword = document.getElementsByName(&quot;q&quot;)[0].value;if(location.href.indexOf(&quot;zh-CN&quot;)&lt;0)&#123;location.href = &quot;https://www.google.com/?&amp;q=#q=&quot; + keyword + &quot;&amp;lr=lang_zh-CN%7Clang_zh-TW&quot;;&#125;else&#123;location.href = &quot;https://www.google.com/?&amp;q=#q=&quot; + keyword&#125;&#125;&#125;)() 添加书签在 safari 中添加一个书签,名字和位置都随意,然后将书签地址改为以上代码 此时在谷歌搜索界面点击该书签就能在中文网页和不限语言之间来回切换了 设置快捷键如果只能用鼠标点的话当然是不可接受的 在系统偏好设置-&gt;键盘-&gt;快捷键中找到如下图位置在应用快捷键中点击中下方的+号,并在弹出窗口中 选择 应用为Safari.app, 标题为之前添加的书签名(必须一模一样), 设置相应的快捷键 使用至此在使用 Google 搜索时就能通过快捷键切换搜索语言了 缺点 js 代码只匹配了 主机名关键词google,在用谷歌搜索图片、视频、新闻等时会跳转到普通搜索结果，不过这几个我倒是从来搜，搜了也不用换语言，所以暂时没有影响。 快捷键并不是全局的, 且优先级不高，我设置的 option + s,光标聚焦在搜索框或地址栏的时候会打出ß符号. 另外原本想按照 Search Engine Switcher 那样做一个扩展的,但是找了半天都没学会怎么下载开发者证书,生成 .safariextension的扩展文件,如果谁会的话请联系我… 参考链接妈妈再也不用担心我的 MacBook 发热了计划2不是你熟悉的 macOS 快捷键Bookmarklet编写指南https://github.com/RayPS/Search-Engine-Switcher END]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>safari</tag>
        <tag>mac</tag>
        <tag>JavaScript</tag>
        <tag>Google</tag>
        <tag>bookmarklet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[暑假第一记]]></title>
    <url>%2F2017%2F07%2F25%2Fcjficuhe8003ne3lv529ogpgm%2F</url>
    <content type="text"><![CDATA[VPS前几天折腾好了国外 vultr 的vps, 打算渐渐远离国内的阿里云了.昨晚随便找了个国外域名和 dns 管理的服务商my.freenom.com注册了 eeljiang.cf, .cf的域名好像是免费一年的,也不知道后面会怎样。 更新后来发现freenom 注册的域名居然屏蔽了大陆的 IP, 也就是不翻墙的话是访问不了的? (还有这种操作) 想了想还是忍痛买了正规的. com吧, 说是忍痛一百块一年其实也不贵。 dns 解析要用国内的服务商才好，国外的解析服务的话，国内访问的时候可能会出现无法解析的情况。看知乎上推荐的最多的 是dnspod。 跑去搜索一看, 原来已经被腾讯收购了……整一个账号也成了腾讯云了，注册完就变成腾讯云用户了，这样一来又感觉和之前阿里云的没啥区别了。 所以截至目前, eeljiang.cn, eeljiang.cf, eeljiang.com, 都是可以访问的了, 其中除了.com,其他两个都将在几个月后过期并不再续费。.cn需要实名备案实在有点难受,最近形势又有点紧 BLOG今晚终于把原来阿里云上的搭建的 wordpress 上的几篇文章转移过来了。博客框架改用了比 wp 更轻量的 hexo。因为轻, 所以很多操作都在命令行上进行了,我还是很喜欢的. 到目前为止 hexo 给我的印象是非常好的.从插件的安装到主题的选择,还有本地和服务端的部署都很顺利.明天准备尝试同时部署到 github 上. 搞笑的是一开始不知道 hexo 是要装在自己电脑端的, 我直接装在了远端 vps 上,虽然也装好了,然而日志提示输入localhost:4000进行访问的时候还没发觉不对劲,强行输入了 eeljiang.cf:4000 才刷出来.后来仔细看了文档才搞明白. 更新在 github 上创建和自己同名的仓库+github.io, 就能生成个人静态博客页面,每个账户有且只有一个这样的静态页面,容量大概是500M.如我 github 的用户名是 jiangeel,那么就创建 名为jiangeel.github.io的仓库.如下图,报错是因为我已经创建过了. 然后你就拥有了一个和普通项目 差不多的页面。 图中的文件是 hexo 生成的作为博客的静态文件，我们可以直接访问项目的名字作为的地址,也就是 http://jiangeel.github.io 来访问由这些静态文件形成的博客界面。 最终效果在全部配置完毕后,最后可以通过以下操作来管理博客界面 在本地用 markdown 编辑器将文章编辑完毕 $ hexo g -d 来一键生成静态文件并部署到远端 (g=generate,d=deploy) 具体配置参考https://hexo.io/zh-cn/docs/index.html]]></content>
      <tags>
        <tag>VPS</tag>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三月份的几个Python练手小项目]]></title>
    <url>%2F2017%2F03%2F17%2F236%2F</url>
    <content type="text"><![CDATA[基本都是单文件的小练习，在一行一行地敲的过程中又再接触、再理解了下面的语法或者使用技巧。 但是我相信以后再遇到还是有一些会忘记，还是要去查去记的。 ‘2048’的小游戏 2.ord3. char = keyboard.getch()4. lambda匿名函数5. 函数定义中的变量可以在定义部分之后，函数调用时所有变量必须在这之前6. defaultdict（）7. line = (1,2,3,4,5)[1:] 等于去掉元祖的第一个元素8. ‘’.join9. ‘’.format(num) html2pdf enumerate() docstring urlparse .format wkhtmltopdf/image re with open() as f: python送爱心 yield worldcloud]]></content>
      <categories>
        <category>未分类</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[修改Hosts实现科学上网]]></title>
    <url>%2F2017%2F03%2F10%2F232%2F</url>
    <content type="text"><![CDATA[&nbsp; 好气啊，在手机上都写地差不多了，到了电脑上被同步成了未完成的状态，又得重写近些天原来十分稳定又快速的shadowsocks开始不在状态了，严重的时候什么都打不开，几分钟就要重启一下。 想去官网提交个工单反馈一下都没办法。（百度是搜不到官网的） 四处搜索的时候就不小心学会了另一个科学上网的方法：修改hosts文件。 hosts hosts文件是一个用于储存计算机网络中各节点信息的计算机文件。这个文件负责将主机名称映射到相应的IP地址。hosts文件通常用于补充或替换网络中DNS的功能。和DNS不同的是，计算机的用户可以直接对hosts文件进行控制。 简单的说hosts文件就是一个和dns服务器一样解析域名的。 区别在于，hosts是存在本地计算机中的，不同的操作系统位置有所不同。 操作系统 路径 Unix、类Unix系统（例如Linux等） /etc/hosts Microsoft Windows %SystemRoot%\System32\drivers\etc\hosts Android /etc/hosts（指向/system/etc/hosts的符号链接) iOS /etc/hosts（指向/private/etc/hosts的符号链接) Mac OS X 10.2和更新版本 /etc/hosts（指向/private/etc/hosts的符号链接） 原理在GFW屏蔽国外网站的方法中，有一种最简单的就是dns污染，将请求的目标域名指向一个无用的IP，从而实现阻止访问。 而修改hosts后，本机就会直接访问对应的IP，而绕过上游DNS服务器。 修改方法访问网站的IP是会变化的，我们需要每隔一到几个月就更新一次hosts文件。 在万能的github上已经有大神整理并定时更新的hosts文件，我们去下载后替换即可。 最新可用的 hosts文件 &nbsp; 这里还有更加方便的方法，即一件更新并替换的工具。 Hosts Tool Pool 优点 不经过 vpn 或者代理商的服务器，直接访问，所以速度快，较为稳定。 免费 使用限制 只能对固定ip的网站访问，并需要https的连接。因此youtube上的视频是加载不了的。（YouTube网页本身能打开） 目标网站IP变动后就需要更新hosts，不能一劳永逸。 hosts的其他用法屏蔽某些网页将需要屏蔽的 域名 和 ip按相同格式写入hosts即可，其中ip改为127.0.0.1。再次访问改域名时会重定向至空白页。]]></content>
      <tags>
        <tag>Hosts</tag>
        <tag>科学上网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[If __Name__ == '__Main__']]></title>
    <url>%2F2017%2F03%2F08%2F209%2F</url>
    <content type="text"><![CDATA[以前看到许多python的小项目，最代码后都会有一句 if __name__ == &apos;__main__&apos;: main() `&lt;/pre&gt; 今天终于查了一下了解了它的作用。 我们知道 python 可以通过将代码封装成一个模块，并在其他代码中`import`。而用`if __name__ == &apos;__main__&apos;`可以判断是否是在cmd直接运行该.py文件。 在`main()`函数前加入了一个判断语句，以此来让脚本判断自己是被当做**模块调用**，还是被**直接运行**的。 * * * 模块是对象，并且所有的模块都有一个内置属性 `__name__`。一个模块的 `__name__` 的值取决于你如何应用模块。 如果 import 一个模块，那么模块name 的值通常为模块文件名，不带路径或者文件扩展名。 但如果像一个标准的程序样直接运行模块，在这种情况下, __name__的值将是一个特别缺省__main__。 总之 运行方式 ‘name‘的值 在cmd中直接运行.py文件 ‘main‘ import入一个.py 文件名不带扩展 从而用if name == ‘main‘来判断是否是在直接运行该.py文件。 当被 import 作为模块调用的时候，if以下的代码就不会被执行，也就是说main()函数不会被执行。 如:##Test.py `class Test: def __init(self):pass def f(self):print &apos;Hello, World!&apos; if name == ‘main‘: Test().f() 图中可以看出: __name__ == &#39;__main__&#39; 而如果： 可以看到 __name__为我的文件test.py的不带扩展的文件名。]]></content>
      <categories>
        <category>未分类</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PyQT5的初体验]]></title>
    <url>%2F2017%2F03%2F07%2F173%2F</url>
    <content type="text"><![CDATA[这是今天吃饭的时候在收藏夹里翻出的，一个很久以前收藏的，实验楼上的免费学习课程。 当初收藏了一定有道理……所以就跟着做了一下。 PyQt 实现简易浏览器 PyQt5的基础用法from PyQt5.QtWidgets import * from PyQt5.QtCore import * from PyQt5.QtGui import * import sys class Color(QWidget): def __init__(self, color, *args, **kwargs): super().__init__(*args, **kwargs) self.setAutoFillBackground(True) palette = self.palette() palette.setColor(QPalette.Window, QColor(color)) self.setPalette(palette) class MainWindow(QMainWindow): def __init__(self, *args, **kwargs): super().__init__(*args, **kwargs) # self.windowTitleChanged.connect(self._my_func) # 设置标题 self.setWindowTitle(&apos;My first App&apos;) # 水平布局 layout = QGridLayout() # # 添加布局 # layout = QVBoxLayout() # 展示的部件列表 widgets = [QCheckBox, QComboBox, QDateEdit, QDateTimeEdit, QDial, QDoubleSpinBox, QFontComboBox, QLCDNumber, QLineEdit, QProgressBar, QPushButton, QRadioButton, QSlider, QSpinBox, QTimeEdit] for item in widgets: layout.addWidget(item()) # color主要是用来测试layout的水平、垂直和网格布局，然而并没有生效 colors = [&apos;red&apos;, &apos;green&apos;, &apos;blue&apos;, &apos;yellow&apos;] for color in colors: layout.addWidget(Color(color)) # 创建按钮 for i in range(5): button = QPushButton(str(i)) button.pressed.connect(lambda x=i: self._my_func(x)) layout.addWidget(button) # 添加工具栏 tb = QToolBar(&apos;Help&apos;) tb.setIconSize(QSize(16, 16)) # 添加到主窗口 self.addToolBar(tb) # 添加按钮动作并夹在图像 button_action = QAction(QIcon(&apos;icons/penguin.png&apos;),&apos;Menu button&apos;,self) button_action.setStatusTip(&apos;This is menu button&apos;) button_action.triggered.connect(self.onButtonClick) button_action.setCheckable(True) tb.addAction(button_action) self.setStatusBar(QStatusBar(self)) # 添加新的菜单选项 button_action2 = QAction(&apos;C++&apos;,self) button_action3 = QAction(&apos;Python&apos;,self) button_action2.setCheckable(True) # 用false应该就是不能打勾状态了 button_action3.setCheckable(False) button_action2.triggered.connect(self.onButtonClick) button_action3.triggered.connect(self.onButtonClick) # 添加按钮动作 button_action4 = QAction(&apos;hello , eeljiang&apos;, self) button_action4.triggered.connect(self.onButtonClick) # 添加菜单栏 mb = self.menuBar() # 禁用原生菜单栏 mb.setNativeMenuBar(False) file_menu = mb.addMenu(&apos;&amp;amp;File&apos;) #file_menu.addAction(button_action) file_menu.addSeparator() file_menu.addAction(button_action4) # 添加二级菜单 build_system_menu = file_menu.addMenu(&apos;&amp;amp;Build System&apos;) build_system_menu.addAction(button_action2) build_system_menu.addSeparator() build_system_menu.addAction(button_action3) widget = QWidget() widget.setLayout(layout) self.setCentralWidget(widget) def onButtonClick(self,s): print(s) def _my_func(self, n): print(&apos;click button %s&apos; % n) def onButtonClick(self, s): dlg = CustomDialog(self) dlg.exec_() # 自定义对话框 class CustomDialog(QDialog): def __init__(self,*args,**kwargs): super().__init__(*args, **kwargs) self.setWindowTitle(&apos;new Dialog&apos;) # 添加按钮选项 QBtn = QDialogButtonBox.Ok | QDialogButtonBox.Cancel | QDialogButtonBox.Cancel buttonBox = QDialogButtonBox(QBtn) buttonBox.accepted.connect(self.accept) buttonBox.rejected.connect(self.reject) layout = QVBoxLayout() layout.addWidget(buttonBox) self.setLayout(layout) # 创建应用实例，通过sys。argv 传入命令行参数 app = QApplication(sys.argv) # 创建窗口实例 window = MainWindow() # 显示窗口 window.show() # 执行应用，进入事件循环 app.exec() # 按钮&amp;gt;布局&amp;gt;部件&amp;gt;窗口 # button&amp;gt;layout&amp;gt;widget&amp;gt;window PyQt5实现简易游览器之前安装的PYQt5不会同时安装这次需要的qtwebkit。需要单独安装。 然而 我的qt之前安装的是5.8，并不能导入qtwebkit。在stackoverflow上找到一个答案说从5.6开始就已经没有了。。 QtWebKit got deprecated upstream in Qt 5.5 and removed in 5.6. Cannot import QtWebKitWidgets in PyQt5 下次再找其他的模块做吧。]]></content>
      <categories>
        <category>未分类</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>PyQt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PIP更换源]]></title>
    <url>%2F2017%2F03%2F06%2F170%2F</url>
    <content type="text"><![CDATA[和linux中一样，在命令行中用pip下载python第三方库的时候虽然方便，但总是很慢。一个不小心就断了，下载个比较大的，比如这回我想要的PyQt5有73M之多，而在50M的电信宽带下也只有15kb/s的速度…… 这次下定决心要解决命令行安装库时改善速度的问题。 临时的方法比如安装PyQt5: pip install PyQt5 -i http://pypi.douban.com/simple `&lt;/pre&gt; 这是使用豆瓣的源，当然还有其他的，比如阿里云的。 这仅对单次有效，显然是不够满意的。 ## 永久的方法 linux／mac： ~/.pip/pip.conf windows： %HOMEPATH%pippip.ini 如果没有的话，需要自己建立新的文件夹以及文件。 对应的系统分别在上面的文件中写入以下配置。 &lt;pre&gt;`[global] index-url = http://mirrors.aliyun.com/pypi/simple/ [install] trusted-host=mirrors.aliyun.com 保存后pip即会默认使用设定的源。]]></content>
      <categories>
        <category>未分类</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>PIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爬虫闯关]]></title>
    <url>%2F2017%2F03%2F06%2F167%2F</url>
    <content type="text"><![CDATA[闯关地址 第一关简单的说，就是需要你不停地按照页面中的五位数字，在游览器地址栏中最后输入，并进入下一个界面。 前两关用到的都是urllib模块。在爬虫中算是最常见了的吧。 import urllib import re tmp_re=urllib.urlopen(&apos;http://www.heibanke.com/lesson/crawler_ex00/&apos;) html=tmp_re.read() index=re.findall(r&apos;输入数字([0-9]{5})&apos;,html) while index: url=&apos;http://www.heibanke.com/lesson/crawler_ex00/%s/&apos; % index[0] print url tmp_re=urllib.urlopen(url) html=tmp_re.read() index=re.findall(r&apos;数字是([0-9]{5})&apos;,html) print html `&lt;/pre&gt; ![](http://www.blog.eeljiang.cn/wp-content/uploads/2017/03/14887258259290.jpg) ## 第二关 ![](http://www.blog.eeljiang.cn/wp-content/uploads/2017/03/14887267097303.jpg) 第二题看起来直观多了，关键只有一个密码，而且最多就是三十个数字之一。~~答案是17~~ &lt;pre&gt;`import urllib import re data={&apos;username&apos;:&apos;Tom&apos;} url=&apos;http://www.heibanke.com/lesson/crawler_ex01/&apos; for num in range(1,31): data[&apos;password&apos;]=num post_data=urllib.urlencode(data) print post_data response=urllib.urlopen(url,post_data) html=response.read() result=re.findall(&apos;密码错误&apos;,html) if not result: print html break 第三关第三关中多了一个csrf保护。也就是每次提交的时候需要多传递一个字串。第二题是乎也有csrf！。。。以下是百科上对csrf的介绍 跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。[1] 跟跨网站脚本（XSS）相比，XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。 一般有两种防御措施： 检查Referer字段 添加校验toke 题目中的就应该属于第二种。 未完。。[TOC]]]></content>
      <categories>
        <category>未分类</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown 语法和 MWeb 写作使用说明]]></title>
    <url>%2F2017%2F03%2F05%2F147%2F</url>
    <content type="text"><![CDATA[Markdown 的设计哲学 Markdown 的目標是實現「易讀易寫」。 不過最需要強調的便是它的可讀性。一份使用 Markdown 格式撰寫的文件應該可以直接以純文字發佈，並且看起來不會像是由許多標籤或是格式指令所構成。 Markdown 的語法有個主要的目的：用來作為一種網路內容的寫作用語言。 本文约定如果有写 效果如下：， 在 MWeb 编辑状态下只有用 CMD + 4 或 CMD + R 预览才可以看效果。 标题Markdown 语法： # 第一级标题 `&amp;lt;h1&amp;gt;` ## 第二级标题 `&amp;lt;h2&amp;gt;` ###### 第六级标题 `&amp;lt;h6&amp;gt;` `&lt;/pre&gt; 效果如下： # 第一级标题 `&amp;lt;h1&amp;gt;` ## 第二级标题 `&amp;lt;h2&amp;gt;` ###### 第六级标题 `&amp;lt;h6&amp;gt;` ## 强调 Markdown 语法： &lt;pre&gt;`*这些文字会生成`&amp;lt;em&amp;gt;`* _这些文字会生成`&amp;lt;u&amp;gt;`_ **这些文字会生成`&amp;lt;strong&amp;gt;`** __这些文字会生成`&amp;lt;strong&amp;gt;`__ `&lt;/pre&gt; 在 MWeb 中的快捷键为： `CMD + U`、`CMD + I`、`CMD + B` 效果如下： _这些文字会生成`&amp;lt;em&amp;gt;`_ _这些文字会生成`&amp;lt;u&amp;gt;`_ **这些文字会生成`&amp;lt;strong&amp;gt;`** **这些文字会生成`&amp;lt;strong&amp;gt;`** ## 换行 四个及以上空格加回车。 如果不想打这么多空格，只要回车就为换行，请勾选：`Preferences` - `Themes` - `Translate newlines to &amp;lt;br&amp;gt; tags` ## 列表 ### 无序列表 Markdown 语法： &lt;pre&gt;`* 项目一 无序列表 `* + 空格键` * 项目二 * 项目二的子项目一 无序列表 `TAB + * + 空格键` * 项目二的子项目二 `&lt;/pre&gt; 在 MWeb 中的快捷键为： `Option + U` 效果如下： 项目一 无序列表 * + 空格键 项目二 项目二的子项目一 无序列表 TAB + * + 空格键 项目二的子项目二 有序列表Markdown 语法： `1\. 项目一 有序列表 `数字 + . + 空格键` 2\. 项目二 3\. 项目三 1\. 项目三的子项目一 有序列表 `TAB + 数字 + . + 空格键` 2\. 项目三的子项目二 ` 效果如下： 项目一 有序列表 数字 + . + 空格键 项目二3. 项目三 项目三的子项目一 有序列表 TAB + 数字 + . + 空格键 项目三的子项目二 任务列表（Task lists）Markdown 语法： `- [ ] 任务一 未做任务 `- + 空格 + [ ]` - [x] 任务二 已做任务 `- + 空格 + [x]` ` 效果如下： [ ] 任务一 未做任务 - + 空格 + [ ] [x] 任务二 已做任务 - + 空格 + [x] 图片Markdown 语法： `![GitHub set up](http://zh.mweb.im/asset/img/set-up-git.gif) 格式: ![Alt Text](url) ` Control + Shift + I 可插入Markdown语法。如果是 MWeb 的文档库中的文档，还可以用拖放图片、CMD + V 粘贴、CMD + Option + I 导入这三种方式来增加图片。效果如下： MWeb 引入的特别的语法来设置图片宽度，方法是在图片描述后加 -w + 图片宽度 即可，比如说要设置上面的图片的宽度为 140，语法如下： 链接Markdown 语法： `email &lt;example@example.com&gt; [GitHub](http://github.com) 自动生成连接 &lt;http://www.github.com/&gt; ` Control + Shift + L 可插入Markdown语法。如果是 MWeb 的文档库中的文档，拖放或CMD + Option + I 导入非图片时，会生成连接。效果如下： Email 连接： &#101;&#120;&#x61;&#x6d;&#x70;l&#101;&#64;&#x65;&#x78;&#x61;m&#112;&#108;&#101;&#x2e;&#x63;&#x6f;&#109;连接标题Github网站自动生成连接像： http://www.github.com/ 这样 区块引用Markdown 语法： `某某说: &gt; 第一行引用 &gt; 第二行费用文字 ` CMD + Shift + B 可插入Markdown语法。效果如下： 某某说: 第一行引用 第二行费用文字 行内代码Markdown 语法： `像这样即可：`&lt;addr&gt;` `code` ` CMD + K 可插入Markdown语法。效果如下： 像这样即可：&amp;lt;addr&amp;gt; code 多行或者一段代码Markdown 语法： 123456function fancyAlert(arg) &#123; if(arg) &#123; $.facebox(&#123;div:&apos;#foo&apos;&#125;) &#125;&#125; ` CMD + Shift + K 可插入Markdown语法。效果如下： `function fancyAlert(arg) { if(arg) { $.facebox({div:'#foo'}) } } ` 顺序图或流程图Markdown 语法： 123张三-&amp;gt;李四: 嘿，小四儿, 写博客了没?Note right of 李四: 李四愣了一下，说：李四--&amp;gt;张三: 忙得吐血，哪有时间写。 12345678st=&amp;gt;start: 开始e=&amp;gt;end: 结束op=&amp;gt;operation: 我的操作cond=&amp;gt;condition: 确认？st-&amp;gt;op-&amp;gt;condcond(yes)-&amp;gt;econd(no)-&amp;gt;op ` 效果如下（ Preferences - Themes - Enable sequence &amp;amp; flow chart 才会看到效果 ）： `张三-&gt;李四: 嘿，小四儿, 写博客了没? Note right of 李四: 李四愣了一下，说： 李四--&gt;张三: 忙得吐血，哪有时间写。 ` `st=&gt;start: 开始 e=&gt;end: 结束 op=&gt;operation: 我的操作 cond=&gt;condition: 确认？ st-&gt;op-&gt;cond cond(yes)-&gt;e cond(no)-&gt;op ` 更多请参考：http://bramp.github.io/js-sequence-diagrams/, http://adrai.github.io/flowchart.js/ 表格Markdown 语法： `第一格表头 | 第二格表头 --------- | ------------- 内容单元格 第一列第一格 | 内容单元格第二列第一格 内容单元格 第一列第二格 多加文字 | 内容单元格第二列第二格 ` 效果如下： 第一格表头 第二格表头 内容单元格 第一列第一格 内容单元格第二列第一格 内容单元格 第一列第二格 多加文字 内容单元格第二列第二格 删除线Markdown 语法： 加删除线像这样用： 删除这些 效果如下： 加删除线像这样用： 删除这些 分隔线以下三种方式都可以生成分隔线： `*** ***** - - - ` 效果如下： MathJaxMarkdown 语法： `块级公式： $$ x = dfrac{-b pm sqrt{b^2 - 4ac}}{2a} $$ \[ frac{1}{Bigl(sqrt{phi sqrt{5}}-phiBigr) e^{frac25 pi}} = 1+frac{e^{-2pi}} {1+frac{e^{-4pi}} {1+frac{e^{-6pi}} {1+frac{e^{-8pi}} {1+ldots} } } } \] 行内公式： $Gamma(n) = (n-1)!quadforall ninmathbb N$ ` 效果如下（Preferences - Themes - Enable MathJax 才会看到效果）： 块级公式：$$ x = dfrac{-b pm sqrt{b^2 - 4ac}}{2a} $$ &#91; frac{1}{Bigl(sqrt{phi sqrt{5}}-phiBigr) e^{frac25 pi}} =1+frac{e^{-2pi}} {1+frac{e^{-4pi}} {1+frac{e^{-6pi}}{1+frac{e^{-8pi}} {1+ldots} } } } &#93; 行内公式： $Gamma(n) = (n-1)!quadforall ninmathbb N$ 脚注（Footnote）Markdown 语法： `这是一个脚注：[^sample_footnote] ` 效果如下： 这是一个脚注：1 注释和阅读更多 Actions-&gt;Insert Read More Comment 或者 Command + .注 阅读更多的功能只用在生成网站或博客时，插入时注意要后空一行。 TOCMarkdown 语法： `[TOC] 效果如下： [TOC] *1. 这里是脚注信息&#160;&#8617;]]></content>
      <categories>
        <category>未分类</category>
      </categories>
      <tags>
        <tag>MWeb</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用Stylish修改网页，加快重复性劳动时的速度]]></title>
    <url>%2F2017%2F03%2F03%2F157%2F</url>
    <content type="text"><![CDATA[stylish简介 利用用户样式管理器Stylish来重新编辑网站的样式。您可利用Stylish为许多网站安装主题和皮肤，也可创建自己的主题和皮肤。 ★ 为Reddit添加黑色风格，使用简约的Facebook，或者更改Google、Twitter或您最爱的任意网站的外观。 ★ 自定义背景、配色方案、字体甚至动画。 ★ 方便地禁用、启用、编辑或删除任意已安装主题。 ★ 利用Stylish的CSS编辑器创建自己的用户样式（主题），然后与数百万Stylish用户共享。 ## &emsp;&emsp;最近需要在一个视频网站上大量地上传视频，并附加封面、简介以及选择一些允许转载等勾选框。 &emsp;&emsp;然而因为宿舍网速慢，每次都需要去上课前挂起上传，白天在教学楼期间用手机远程操控寝室里的电脑进行确认。由于手机屏幕小，原生网页中的选项按钮比较小，并且有许多元素都没有用到，所以计划用chrome的stylish插件对上传的页面修改一下，方便手机远程操控时的操作，毕竟上传视频的电脑反应比较慢，多滚动一下页面也要迟钝好久。在几十上百次的上传过程中能省下不少时间，也省下一些流量。 &emsp;&emsp;在chrome的商店中搜索并安装stylish后，可以直接在地址栏右边的插件图标上点击左键，并选择新建样式，插件会自动跳转到编辑页面。 &emsp;&emsp;底部的应用对象栏代表中间所编辑的css代码作用的网页地址，其中地址支持完整的页面地址、网址前缀和匹配正则表达式的相应网页。 &emsp;&emsp;我简单编辑的样式如下：（其实绝大部分都是隐藏了无用的元素，把几个不能选择的按钮隐藏，并扩大了要选择的按钮。） .card-staff { display: none } .card-label { display: none } .card-label { display: none } .related-href-ul { display: none } .cwi-right { display: none } .cwi-left-tbox { height: 100px; } .cwi-txt1 { height: 100px; } .card-btn-box .card-btn-box { position: absolute; right: 350px; width: 400px; } .card_allow p[data-allow=&apos;false&apos;] { display: none; } .type-tit + p { display: none } /* .allow-tit +p{ display:none; } */ .page-footer { display: none; } .cardupload-secbox { height: auto } .cf-bottom { display: none; } .au1-box2{ padding:20px; } .au1-box1{ padding:20px; } .confirm-pub{ padding:20px; position:absolute; left:30px; } &nbsp;&nbsp;添加后保存，返回网页，可以看到已经有了一些变化。 &emsp;&emsp;看起来并不优雅，变化也没有很大，但是对于小屏幕的手机操作来讲已经是很大的进步了。仔细看可以发现页面短了许多，因此游览时不需要滚动到下面再点击确认发布了在手机上滚动网页真的很难。 相关技能： 远程控制软件：teamviewer（个人版免费) chrome检查元素工具 css样式 [TOC]]]></content>
      <categories>
        <category>未分类</category>
      </categories>
      <tags>
        <tag>stylish</tag>
        <tag>chrome</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python与c的不同]]></title>
    <url>%2F2016%2F10%2F29%2F125%2F</url>
    <content type="text"><![CDATA[数组有()和[],其中()中值定义后为不可修改,[]可以修改值可以return多个值,代表返回一个()数组def 定义函数,不需要返回类型if和for用冒号继承写在类名后()内类内的函数要参数self,调用类内属性要self.name构造函数init()与或非用and or not存在没有顺序的 键值对:字典import导入其他py文件包裹传递:在函数括号内参数前加表示传入的是个数组(如果是字典的话加*)]]></content>
      <categories>
        <category>未分类</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[把Home独立分区挂载]]></title>
    <url>%2F2016%2F09%2F22%2F105%2F</url>
    <content type="text"><![CDATA[背景： 我的电脑只有500g机械+64g固态。某天发现有30g机械空余着，便安装了linux玩。没想到一用就变成了几天不开win了。linux用的一多，之前给的30g也瞬间不够了，就打算再从win那里挤一点出来，扩充一下。目标：打算按网上许多人说的，把/home单独挂载出来，以后出了问题，重装系统什么的也方便。过程： 在windows下用分区助手割下50g空余空间。 然而：磁盘分完后，原来隔壁的/boot分区就没了！ 整个文件夹下都空了……无奈只好再用刻录在u盘的启动盘把刚分出来的50g再完整装一遍linux，然后把新系统boot中的文件拷贝到原来空的boot中去。然后再在upstart模式下修改/etc/fstab中挂载boot的UUID。在拷贝boot的过程中，用了rsync命令来进行同步。同步完了再用diff检查一下两个文件夹的异同（可以用meld这个图形化工具来分析，比较直观）。终于能正常启动了以后，再到启动盘中，再像拷贝boot那样，在准备好的50g空闲分区中建立/home，把原来的home同步过去，再把原来home给清空（不然挂载到新分区了后，老地方还是占用这这么多空间），无误后修改fstab，重启，完成。（其实一开始我单纯的直接在fstab中添加了一行新分区home的uuid和后面的常规参数，而新分区里其实并没有home文件夹以及里面的数据，导致卡在登陆界面，无限循环在输入密码又无法载入桌面的情况……）]]></content>
      <categories>
        <category>未分类</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>分区挂载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu下软件安装记录]]></title>
    <url>%2F2016%2F09%2F22%2F109%2F</url>
    <content type="text"><![CDATA[2016年09月17日09:33:02 cheat2016年09月17日09:33:13 laptop-mode-tools 挂起问题 未解决2016年09月17.-09B*2016年09月17日10:34:10 locate命令 用root来updatedb更新信息库。2016年09月17日10:59:50 永久添加alias 目录~/bashrc2016年09月17日12:36:20 nload 监控总体网速2016年09月17日13:06:18 sudo iftop -n -i 网卡.2016年09月17日14:14:25 装deb软件 dpkg -i xxx.deb，sudo apt-get -f install2016年09月17日14:24:16 安装了virtualbox 和xp2016年09月17日16:34:02 安装了 speedometer 目前比较好看的 图形 监控2016年09月17日16:49:42 安装了rar2016年09月17日16:58:46 安装了font-manager 然而启动会卡死，已删除2016年09月17日19:00:59 安装了wps2016年09月17日19:38:16 顶部网速监控 indicator-sysmonitor2016年09月17日19:39:59 添加公钥 sudo apt-key adv –keyserver keyserver.ubuntu.com –recv-keys 8D5A09DC9B9290062016年09月17日20:47:14 编写了ss启动脚本.2016年09月17日21:26:48 ss开机自启成功. sudo vim /etc/rc.local2016年09月17日22:50:40 挂载了u盘。但只是只读 查看uuid:blkid2016年09月17日22:50:55 开启开机详细信息（删掉了一个“quiet”）2016年09月17日22:55:01 安装了GParted2016年09月18日11:08:27 安装了gvim2016年09月18日13:55:48 安装了keynav,然而并不好用。2016年09月19日06:24:51 修复/etc/fstab 文件。删除了之前添加的u盘挂载。开机成功！！！2016年09月19日16:32:35 安装了dconf-tools，类似注册表，修改默认启动的终端2016年09月21日23:21:23 安装了jre和eclipse2016年09月23日04:15:48 安装了meld.]]></content>
      <categories>
        <category>未分类</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows引导修复记录]]></title>
    <url>%2F2016%2F09%2F20%2F96%2F</url>
    <content type="text"><![CDATA[昨天刚把linux进不去的问题解决好，今天windows又进不去了……原因是这样的：原来的开机过程是，先进入windows的选择系统黑白界面，如果选了linux，就再进入ubuntu的紫色grub，再选择进入ubuntu或linux救援模式或进入win10（也就是跳到黑白选项）。如此一来，开机要走好多步，而进入了grub以后又依旧能返回去选择win10，那我就想着把第一个黑白菜单默认进入linux，然后跳过等待时间不就好了嘛。当我在windows用easyBCD设置默认系统和跳过等待后（其实在我的电脑右键属性里也能直接设置），就再也进不去windows了……原因分析：开机直接跳过黑白菜单后来到grub，进入linux无问题，然而如果想进入win的话，又会马上加载到grub…仔细想想应该是因为黑白菜单被跳过了.…没错，当初在grub下选择win的确是进入黑白菜单继续选择系统而已，算来算去，原来是进入win需要按一下，进入linux需要按两下；现在哪怕我成功了，也只是变成进入linux按一下，进入win按两下…解决过程：1.百度搜索到windows在c盘有一个boot.ini，里面记录了开机等待的时间。然而在linux下挂载c盘的分区后进入查看，并没有此文件。2.搜索关于启动引导的修复结果中，几乎全部都是grub或mbr损坏、被覆盖等原因，其中大多都是windows能进，linix不能引导的问题。然而我是两者都正常，只是没时间而已……3.最后借助了第三方援助，用同学刻录了pe的u盘启动，进入后对着pe的我的电脑，右键属性里改回30s等待时间，重启，完成。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[添加Swap及开启挂起记录]]></title>
    <url>%2F2016%2F09%2F19%2Fcjficuhec003te3lv7g4nuli3%2F</url>
    <content type="text"><![CDATA[有人说内存比较大的时候（比如我的是8g），就不需要swap内存了。在windows上好像的确是不太需要虚拟内存了。然而当我想要挂起的时候，发现挂起后就无法唤醒了。 经过测验：1.并非外接显示器的缘故。只用笔记本自带的显示器也无法唤醒（显示器是新添加的，谁知道会不会是它的缘故呢）2.缺失laptop-mode-tools. 经过$sudo apt-get install laptop-mode-tools后，再cat /proc/sys/vm/laptop_mode，发现数字是0，因此为非启动状态。于是编辑 /etc/laptop-mode/laptop-mode.conf,设置ENABLE_LAPTOP_MODE_ON_AC=1，看起来是连着电源的时候也能挂起的意思吧。再sudo laptop-mode start,最后再cat 一遍/proc/sys/vm/laptop_mode，结果是2了。小小激动了一把。然而并没什么用。3.几天后想到休眠时把内存中的东西放到硬盘里，也许中间需要swap来过度什么的。又想到自己没有swap，所以打算添加一个swap分区。 添加过程：1.自己的ubuntu是笔记本上剩下的30g硬盘，几乎全装给了 / 目录，而swap又需要内存的一半到2倍左右，也就是5-10g吧。2.搜索到添加swap有两种方式：1.传统分区添加。2.比较方便的创建一个大文件，然后转化成swap。遂选择第二种。3.首先用dd命令创建10g的空间,创建在/root/swapfile下。$dd if=/dev/zero of=/root/swapfile bs=1M count=102404.然后将文件转化为swap格式。$mkswap /root/swapfile5.启用swap文件:$swapon /swapfile提示权限644的权限不好，暂时不知道为啥，就根据系统的建议改成600吧 $chmod 600 /root/swaofile6.最后$free 命令可以看到的确有了10g的swap空间。7.在/etc/fstab中添加一行,这样swap就每次开机有效了！/root/swapfile swap swap defaults 0 0(估计比较特殊吧，都不用uuid的)8.另外之前乱修改fstab搞得无法启动系统了，所以给fstab加了chattr +i，今天又忘记了，sudo了半天都修改不了，花了很久才意识到……]]></content>
      <categories>
        <category>Linux</category>
        <category>未分类</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Swap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu第一次系统损坏记录]]></title>
    <url>%2F2016%2F09%2F19%2F89%2F</url>
    <content type="text"><![CDATA[不知名原因某一次重启后（很久没重启了），忽然无法进入系统了。查看系统启动日志有很多failed的加载项，然而并看不懂，关键字也无法搜索到。海量搜索可能原因后总结目前情况：1.grub正常，可以选择正常启动或进入救援模式等。2. resume模式带中文，但全是乱码，看不懂无法使用。3.可以进入救援模式，以root身份修改文件。（找到出问题的配置文件应该就能解决了）4.然而并不知道是什么原因，所以不知道该修改什么文件。 5.根据一大堆启动日志来看，failed的出现都是在加载引导系统的时候出的问题。同时根据网络上搜索到的解决方案来看，把我的情况模糊匹配成/etc/fstab这个文件出问题了吧。（没错我的确在学习u盘挂载的时候修改过了。）6.vi编辑fstab，删除最后一行当初为了挂载u盘添加的u盘的uuid等信息后reboot进入正常模式。成功！7.总结原因：在fstab中添加的是系统启动时挂载的磁盘，之前都没出问题是因为u盘没拔出，所以即使重启也能正确挂载。而这次u盘被拔出后无法挂载故启动不能。经测试，插入u盘后便能成功启动。总之，还是删掉fstab中的u盘挂载代码吧，毕竟ubuntu里u盘插上就已经能自动挂载了。。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VI的一些基本用法]]></title>
    <url>%2F2016%2F02%2F17%2F82%2F</url>
    <content type="text"><![CDATA[1.关于退出::wq! —-强制保存退出:wq —- 保存退出: x —– 作用和:wq 一样ZZ —- 作用和:wq一样，(注意Z是大写的，并且不是在命令模式):q —- 退出:q! — 强制退出========================================================2.关于移动:h : 在当前行向左移动一个字符j: 移动到下一行k:移动到上一行l:在当前行向右移动一个字符Ctrl +f: 向前滚动一页Ctrl +b:向后滚动一页:n 将光标定位到第n行: $ 将光标定位到最后一行0 将光标定位到本行的行首$ 将光标定位到本行的行尾G 将光标定位到本文章的最后一行，与: $功能相同。H 将光标定位到屏幕的顶端M 将光标定位到屏幕的中间L 将光标定位到屏幕的底端===========================================================3.关于搜索：/: 后面跟要查找的东西，在文件中向前搜索?:后面跟要查找的东西，在文件中向后搜索n: 向前重复搜索N: 向后重复搜索===========================================================4.关于复制yy: 复制光标当前行nyy: 复制光标当前行到当前行以下的n-1行:1,100 co 200 将1~100的内容复制到第200行。:100,102 co $ 将100~102行的内容复制到最后一行。===========================================================5.关于粘贴:p : 粘贴到当前行的下一行P(大) : 粘贴到当前行的 上一行===========================================================6.关于删除.剪切:dd 删除当前行ndd 与nyy相似dw 删除一个单词ndw 与ndd相似x 删除一个字符nx 删除n个字符dG 删除当前光标到文件末尾的所有内容。d0 删除当前光标到本行行首的所有内容d$ 删除当前光标到本行行尾的所有内容:1,100d 删除1~100:100d 删除第100行:1,100 mo $ 将1~100行的内容移动到最后一行。======================================================7.关于插入：i: 在当前位置的字符前面进入插入模式I: 在当前行的开头进行插入a: 在当前位置的字符后面进入插入模式A: 在当前行的结尾进行插入o: 在当前行下面打开一个新行进行插入O:在当前行上面打开一个新行进行插入======================================================8.关于撤销:u: 撤销上一次的更改=======================================================9.关于替换：regexp:是要匹配的式样replacement: 是要替换的字符串:s /regexp/replacement ————————-替换当前行出现的第一个式样:s/regexp/replacement/g————————-替换当前行所有的匹配:%s/regexp/replacement/g———————–替换文件中所有匹配式样==========================================================PS: 还有一个重要的命令就是”.” 命令，这个命令是用来重复上一命令的]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【转】神器——Chrome开发者工具]]></title>
    <url>%2F2016%2F02%2F16%2F64%2F</url>
    <content type="text"><![CDATA[原文地址 这里我假设你用的是Chrome浏览器，如果恰好你做web开发，或者是比较好奇网页中的一些渲染效果并且喜欢折腾，那么你一定知道Chrome的开发者工具了。其实其他浏览器也有类似工具，比如Firefox下的firebug。本文将会详细讲述如何使用Chrome开发者工具，希望里面有些让你感到惊艳的东西！即使你不用Chrome，那么文中的某些内容也会相当有用。 首先啰嗦一下如何打开开发者工具吧。可以直接在页面上点击右键，然后选择审查元素；或者是打开Tools–Developer Tools；或者是用快捷键 Command Option + I 打开。打开后我们看到的界面大概如下： &nbsp; Google Chrome一共提供了8大组工具： Elements: 允许我们从浏览器的角度看页面，也就是说我们可以看到chrome渲染页面所需要的的HTML、CSS和DOM(Document Object Model)对象。此外，还可以编辑这些内容更改页面显示效果； Network: 可以看到页面向服务器请求了哪些资源、资源的大小以及加载资源花费的时间，当然也能看到哪些资源不能成功加载。此外，还可以查看HTTP的请求头，返回内容等； Sources: 主要用来调试js； Timeline: 提供了加载页面时花费时间的完整分析，所有事件，从下载资源到处理Javascript，计算CSS样式等花费的时间都展示在Timeline中； Profiles: 分析web应用或者页面的执行时间以及内存使用情况； Resources: 对本地缓存（IndexedDB、Web SQL、Cookie、应用程序缓存、Web Storage）中的数据进行确认及编辑； Audits: 分析页面加载的过程，进而提供减少页面加载时间、提升响应速度的方案； Console: 显示各种警告与错误信息，并且提供了shell用来和文档、开发者工具交互。强大的Chrome开发者工具提供了很棒的提示功能，当我们把鼠标悬停在某些项时，会显示一些很有用的提示信息，有时候我们可以得到意想不到的收获。此外，开发者工具还提供了Emulation功能，做移动开发时特别有用。下面先详细研究一下8大工具的使用方法。 ElementsElements工具像一把手术刀一样“解剖”了当前页面，我们看到的Elements页面一般像这样子： 图中标记为1的红色区块为页面HTML文件，HTML中的每个元素比如&amp;lt;body&amp;gt;、&amp;lt;p&amp;gt;都是一个DOM节点，所有的DOM节点组成了DOM树。我们完全可以把红色区块1当做是DOM树，把HTML元素标签看做DOM节点。 当我们在这里选中某一DOM对象时，网页中相应元素也会被阴影覆盖。我们可以对DOM对象进行修改，修改后结果会在页面实时显示出来。此外，还可以用 Command + f 搜索DOM树中指定的内容，或者是以HTML形式更改页面元素，如下图： &nbsp; 选中DOM对象之后右键即可以看到一些辅助的功能，如图中标记为2的区块所示： Add Attribute: 在标签中增加新的属性； Force Element State: 有时候我们为页面元素添加一些动态的样式，比如当鼠标悬停在元素上时的样式，这种动态样式很难调试。我们可以使用Force Element State强制元素状态，便于调试，如下图： ![图4\. 强制元素状态](http://xuelangzf-github.qiniudn.com/20140919_CDT_Element_dynamic_style.gif) Edit as HTML: 以HTML形式更改页面元素； Copy XPath: 复制XPath； Delete Node: 删除DOM节点； Break On: 设置DOM 断点。图中被标记为3的蓝色区块显示当前标签的路径：从html开始一直到当前位置，我们单击路径中任何一个标签，即可以跳转到相应标签内容中去。 图中标记为4的蓝色区块实时显示当前选中标签的CSS样式、属性等，一共有以下5小部分： Styles: 显示用户定义的样式，比如请求的default.css中的样式，和通过Javasript生成的样式，还有开发者工具添加的样式； Computed: 显示开发者工具计算好的元素样式； Event Listeners: 显示当前HTML DOM节点和其祖先节点的所有JavaScript事件监听器，这里的监听脚本可以来自Chrome的插件。可以点击右边小漏斗形状(filter)选择只显示当前节点的事件监听器。 DOM Breakpoints: 列出所有的DOM 断点； Properties: 超级全面地列出当前选中内容的属性，不过基本很少用到。实际应用中我们经常会用到Styles，如下图： 图中标记为1的+号为New style rule，可以为当前标签添加新的选择器，新建立的样式为inspector-stylesheet。此外，也可以直接在原有的样式上增加、修改、禁用样式属性，如图中标记2显示。 在New style rule右边为Toggle Element State，选择后会出现标记3显示的选择框，如果选中:hover后，即可以看到鼠标悬停在页面元素上时的CSS样式了，作用类似于前面的Force Element Satte，更多内容可以看:hover state in Chrome Developer Tools 。 更强大的是，开发者工具以直观的图形展示了盒子模型的margin、border、padding部分，如标记5所示。下面动态图给出了盒子模型的一个示例： Network有时候我们的网页加载的很慢，而相同网速下，其他网页加载速度并不慢。这时候就得考虑优化网页，优化前我们必须知道加载速度的瓶颈在哪里，这个时候可以考虑使用Network工具。下图为我的博客首页加载时的Network情况： 请求的每个资源在Network表格中显示为一行，每个资源都有许多列的内容(如红色区块1)，不过默认情况下不是所有列都显示出来。 Name/Path: 资源名称以及URL路径； Method: HTTP请求方法； Status/Text: HTTP状态码/文字解释； Type: 请求资源的MIME类型； Initiator解释请求是怎么发起的，有四种可能的值： Parser：请求是由页面的HTML解析时发送的； Redirect：请求是由页面重定向发送的； Script：请求是由script脚本处理发送的； Other：请求是由其他过程发送的，比如页面里的link链接点击，在地址栏输入URL地址。 Size/Content: Size是响应头部和响应体结合起来的大小，Content是请求内容解码后的大小。进一步了解可以看这里Chrome Dev Tools - “Size” vs “Content”； Time/Latency: Time是从请求开始到接收到最后一个字节的总时长，Latency是从请求开始到接收到第一个字节的时间； Timeline: 显示网络请求的可视化瀑布流，鼠标悬停在某一个时间线上，可以显示整个请求各部分花费的时间。以上是默认显示的列，不过我们可以在瀑布流的顶部右键，这样就可以选择显示或者隐藏更多的列，比如Cache-Control, Connection, Cookies, Domain等。 我们可以按照上面任意一项来给资源请求排序，只需要单击相应的名字即可。Timeline排序比较复杂，单击Timeline后，需要选择根据Start Time、Response Time、End Time、Duration、Latency中的一项来排序。 红色区块2中，一共有6个小功能： Record Network Log: 红色表示此时正在记录资源请求信息； Clear: 清空所有的资源请求信息； Filter: 过滤资源请求信息； Use small resource raws: 每一行显示更少的内容； Perserve Log: 再次记录请求的信息时不擦出之前的资源信息； Disable cache: 不允许缓存的话，所有资源均重新加载。选择Filter后，就会出现如红色区块3所显示的过滤条件，当我们点击某一内容类型(可以是Documents, Stylesheets, Images, Scripts, XHR, Fonts, WebSockets, Other)后，只显示该特定类型的资源。在XHR请求中，可以在一个请求上右键选择“Replay XHR”来重新运行一个XHR请求。 有时候我们需要把Network里面内容传给别人，这时候可以在资源请求行的空白处右键然后选择Save as HAR with Content保存为一个HAR文件。然后可以在一些第三方工具网站，比如这里重现网络请求信息。 选定某一资源后，我们还可以Copy as cURL，也就是复制网络请求作为curl命令的参数，详细内容看 Copying requests as cURL commands 此外，我们还可以查看网络请求的请求头，响应头，已经返回的内容等信息，如下图： 资源的详细内容有以下几个： HTTP request and response headers Resource preview: 可行时进行资源预览； HTTP response: 未处理过的资源内容； Cookie names and values: HTTP请求以及返回中传输的所有Cookies； WebSocket messages: 通过WebSocket发送和接收到的信息； Resource network timing: 图形化显示资源加载过程中各阶段花费的时间。 补充解释[XPath] XPath 是一门在 XML 文档中查找信息的语言。XPath 用于在 XML 文档中通过元素和属性进行导航。比如在图2中， &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;attribute&quot;&gt;href&lt;/span&gt;=&lt;span class=&quot;value&quot;&gt;&quot;https://github.com/NUKnightLab/TimelineJS&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;这里&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;title&quot;&gt;a&lt;/span&gt;&amp;gt;&lt;/span&gt; 这里a标签的Xpath为：/html/body/div[2]/p[1]/a，解读为：html里面body标签的第二个div标签的第一个p标签下的a标签。 [HTML DOM事件] HTML DOM允许我们在某一事件发生时执行特定的JavaScript脚本，这里的事件可以是： 鼠标移到某元素之上； 窗口或框架被重新调整大小； 文本被选中； 用户在HTML元素上单击； 某个键盘按键被按下…这里事件发生时执行的javascript脚本就是事件监听器。 [DOM 断点] DOM 断点（DOM Breakpoints）可以监听某个 DOM 被修改情况，在Elements中某个元素上右键可以设置三种不同情况的断点： 子节点修改 自身属性修改 自身节点被删除设置后 DOM Breakpoints 列表中就会出现该 DOM 断点。 一旦监听的DOM被修改时，断点就会定位到执行修改操作的代码，这对于绑定了多个事件的 DOM 调试有很大的帮助。 [XMLHttpRequest] XMLHttpRequest是一个浏览器接口，使得Javascript可以进行HTTP(S)通信。XMLHttpRequest 对象用于在后台与服务器交换数据，这样就可以 在不重新加载页面的情况下更新网页 在页面已加载后从服务器请求数据 在页面已加载后从服务器接收数据 在后台向服务器发送数据更多关于XHR的内容可以看阮一峰老师的XMLHttpRequest Level 2 使用指南。 [WebSocket] WebSocket规范定义了一种 API，可在网络浏览器和服务器之间建立“套接字”连接。简单地说：客户端和服务器之间存在持久的连接，而且双方都可以随时开始发送数据。这样就解决了长期以来只能由客户端发起请求才能从服务器获取信息这一问题。 更多关于WebSocket的内容可以看WebSockets 简介：将套接字引入网络 [本文环境] 操作系统：OS X 10.9.4 Chrome版本：Version 37.0.2062.120参考：Chrome DevTools OverviewIntroduction to Chrome Developer ToolsChrome Dev Tools: Networking and the Console &nbsp; &nbsp; &nbsp; &nbsp;]]></content>
      <categories>
        <category>chrome</category>
      </categories>
      <tags>
        <tag>Chrome</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【转】Web建站技术中，HTML、HTML5、XHTML、CSS、SQL、JavaScript、PHP、ASP.NET、WebServices是什么？]]></title>
    <url>%2F2016%2F02%2F16%2F46%2F</url>
    <content type="text"><![CDATA[一个学期前我也和楼主差不多不知道这些都是啥，一个学期之后差不多都弄懂了，来讲讲自己的理解吧 &gt; &lt; 因为接触的时间不是很长，有错误的地方欢迎指正~ 首先要知道网站访问大概是什么个过程：假设你在浏览器地址栏输入这个问题的地址 访问过程和下图差不多，浏览器和服务器交流，服务器和数据库交流（有时候数据库就在服务器那台机子上） HTML 与 CSS你家电脑拿到一个 html （就是上图 HTTP 响应的 body 里的内容）之后，就会对它进行解析渲染。HTML 就是一种标记语言。类比一下，大家在论坛上经常会用一些代码来添加富文本内容，举一些栗子： 用来贴图 用来贴地址 表示标签里的文字应该被删掉（默认添加删除线效果）这种论坛代码也是一种标记语言，HTML 的作用就和它差不多。服务器返回给你的html文件里面，写的是一些代码，大概是这样的： .jpg) 浏览器拿到这些代码之后，分析一下给你渲染好页面显示出来，如果不用css，效果是这样的，按照浏览器默认的样式显示出列表、图片、超链接、输入框、按钮等等： .jpg)是不是觉得默认样式有点看瞎狗眼呢……所以很多时候我们需要自定义样式，现行通用的规定样式的语言是CSS，我们可以用它写一些定义样式的代码，然后在 html 文件里用一个&lt;link&gt;标签把这些规定样式的 CSS 代码与表达内容语义的 HTML 代码关联起来，然后你就能看到一个符合人类正常审美的页面了: .jpg)CSS 代码的格式基本是比如知乎顶上那个蓝色的导航条，它的 CSS 大约是这样的 .jpg)第一个属性对应的代码翻译成人话，就是它的位置（position）应该是不动（fixed）的，浏览器会兢兢业业地去实现这段代码要求实现的效果， 所以你在页面上翻来翻去顶上那个导航条都会死死地黏在窗口顶部不跟着滚动。再拿里面的其他几个属性做栗子解释一下就是： left 和 top 为零指明这个导航条要紧贴着窗口的左上角 width 和 height 指定这个导航条的宽和高 background 指明这个导航条的背景是一种渐变的蓝色浏览器就会根据这些 CSS 代码，“画”出对应的样式。 HTML 5 与 XHTML像人的语言一样，网络上的网页里的 HTML 代码也不一定是标准的，好比有时候你发音不太标准，别人会去猜测你说的到底是什么一样，有些时候前端程序猿不小心写错了 HTML，浏览器也会试图猜测他们原来想写的是什么，做对应的渲染，而猜是要有一个常识做依据的。加上有些浏览器支持一些标签，有一些又不支持，以及其他混乱的情况，为了防止大家鸡同鸭讲，我们需要对 HTML 代码里能有什么标签，标签怎么写，标签可以有什么属性这些东西有一定的共识，建立一个通行的标准，HTML5 就是其中一个比较新的标准。这个标准新加了很多可以用的标签和属性，然后各大浏览器也吭哧吭哧按这个标准去实现了很多这些新加的标签和属性，本来前端程序员要写一堆代码去实现的效果，现在浏览器都给你实现好了，只要写两三行，调用一下浏览器给你实现的部分就能搞定，简单愉快，所以很多人都在热情地推广这个标准~（当然新标准也不可能是完美的，总会有一些问题，怕跑题这里按下不表~） 至于 XHTML，就是 HTML 的近亲 XML 和 HTML 自己的杂交品种，对语法要求比较严格，并且为了兼容 XML，在语法上与 HTML 有一些不同~ JavaScript 与浏览器脚本有了表示内容和语义的 HTML，规定样式的 CSS，得到的是一个静态的页面，没什么动画（其实用 CSS 还是可以有一些动画的，不过这个跑题了），按 F5 才会刷新数据，都 21世纪了，这么呆板单调的网页怎么能展现我大智人种族的创造性口胡！于是我们有了 Javascript（JS） 来给页面添加一些动态的效果，比如知乎问题的标签，鼠标移上去会弹出一个小窗口，这个就是 JS 实现的效果啦。 .jpg)浏览器都会帮你实现一些 JS 可以用的工具（函数，对象什么的），你只要写一些 JS 的代码，保存在 xxx.js 里，在 html 文件中用 &lt;script&gt; 关联进来就可以用了，像上图这个效果应该就包括了 鼠标悬停到标签上时创建一个新的 &lt;div&gt; 小窗口 用 JS 向知乎服务器发送一个请求，得到这个小窗口应该显示的数据，放在这个小窗口里（这就是所谓的AJAX，不用刷新就能与服务器进行交互，更新页面的一小部分~）浏览器拿到这样的代码，就会解析并实现出相应的效果，楼主问的浏览器脚本，指的就是这样子的代码。其实用来写浏览器脚本的，也不是非得JavaScript 不可，当年还为到底用什么语言写这种代码有过一段战火纷飞的时期，但现在尘埃落定，各大浏览器都默认了：请用 JS 写这些动态效果的代码给我解析~ 以上就是前端部分的内容，下面简述一下后端的东西吧&gt; &lt; Web Server 和 Web Services浏览器给服务器发一个请求，服务器不是一看就知道怎么响应的。首先这些请求和响应要有一个通用的写法，也就是要有一个协议，常用的是 HTTP 协议。像最前面的图，服务器的响应写了一个状态码 200 OK ，是 HTTP 协议里约定俗成的一个东西，服务器写 200 OK 在响应里，表示“你请求的这个东西我有”，如果是404 Not Found，就是“你请求的这个东西我这里没有”。HTTP 响应里还包括很多东西，比如 Content-type 表示服务器发过来的文件类型是什么（文本？动画？图片？音频？），这样发过去了人家浏览器好知道怎么展示给用户看。人家服务器怎么知道按协议要写什么东西进去呢，这就是 Web Server 干活的时候了。 形象化一下HTTP响应，大概就长这样： .jpg)再上个锤子，浏览器和服务器之间请求响应的过程大致是长这样的，右下角的那些东西就是由 Web Server 生成的（服务器脚本可以做一些改动，但这些一般是 Web Server 的份内活）： .jpg)再比如说很多时候你访问一个网站，浏览器里输的地址并没有写明你请求的文件，比如这个问题的地址是：但知乎的服务器其实返回了一个html给你，服务器怎么知道这个地址对应要返回什么样的 html 代码给你的？也是 Web Server 干的活。 除了浏览器输地址敲回车这种赤裸裸的访问，客户端与服务器的交互还有很多种，比如： 前面提到的用 JS 完成的 AJAX，有点像浏览器和服务器之间的悄悄话~还有其他应用软件与服务器的交互，比如： 微信、QQ 与腾讯的服务器的交互 网游客户端与网游公司服务器的交互 搜索引擎用来搜集网页信息的程序（爬虫）与各种各样的网站服务器的交互 只要你知道用什么地址访问、怎样访问人家的服务器，并且有相应权限，你也可以自己写一些程序去和他们的服务器交互（比如用微博API - 新浪微博API获取微博，开发第三方应用或者做数据分析）。从这些栗子里可以看出，客户端与服务器的交互的主体、客体、载体是五花八门的： 服务器可以是大型机也可以是个人电脑，只要能跑相应的程序就行 客户端像前面举的栗子里一样，可以是各种软件，而且这些软件不一定运行在个人电脑上，也可以是手机、平板、智能穿戴设备等等 有时候不是传生成好的 HTML 或者其他服务器上已经有的文件，而是传输经过一定逻辑处理后生成的字符串或者其他各种封装好的数据像前面提到的 HTML 需要有一定标准一样，为了防止混乱和鸡同鸭讲，我们又需要先对这些机器需要怎么交互达成一定共识，再让它们进行交流。人与人之间通信，需要先有一种大家都认识的写法（比如简体字/繁体字）和一种彼此都懂的语言（比如普通话/广东话）。要让这些形形色色的机器能够通过网络进行交互，我们就需要指明一种协议（比如 HTTP/HTTPS）和一种数据封装格式（比如 HTML/XML），Web Server 提供的 Web Service，指的就是这种协议+格式的交流体系。不过 Web Service 的生态系统和 HTML 的标准不一样，用户可以选择的协议和数据封装格式更多，普通的网站访问用的 HTTP + HTML 只是其中一种，一些封闭系统内的交流还可以自己定义一个协议和格式来用（比如 QQ）。 Web Service 传输的数据再经由本地客户端（浏览器、QQ/微信，网游客户端等）的分析渲染，就能够以普通人能够理解的形式展现出来。此外还有一些 Web Service 并不是为普通用户设计的，像前面提到的微博API，是用来给程序猿进行二次开发的~ 除了提供 Web Service， Web Server 还会兼顾很多功能，包括提供缓存，平衡负载，这样在访问量比较大的时候能有有条不紊地接客。常见的现成的 Web Server 有开源的 Apache、Nginx和微软的IIS，你也可以用一些工具（比如 Node.js ）自己定制一个。因为 Web Server 需要比较好的性能，所以投产时用的 Web Server 通常是C/C++/Java写的，但是其实很多语言都可以写，而且配合上语言底层的优化和好的模型，其他语言写的 Web Server也可以有不错的表现。 PHP ，服务器脚本，Web Framework开头那张图里服务器接到请求之后可以给访客发送对应的文件，但21世纪的服务器怎么可能只会“接请求-发文件”这么弱智的一招呢，人家还可以处理你上传来的文件的！还可以接受你发过来的各种请求，去操作服务器本地的文件or数据库的！要干这些事，自然服务器那边也少不了要有代码了，这些代码就是服务器脚本。前面说的 Web Service 传输的数据，主要也是由服务器脚本生成，再交由 Web Server ，按照某种协议套好整个响应的格式，返回给客户端的。 同一个网址，每个人看到的页面不一定是一样的，比如知乎首页的网址都是但是没登陆和登陆之后看到的东西不一样，登陆之后每个人看到的导航栏的用户信息，关注的动态，都不一样。服务器脚本可以对这些不同的状态，生成不同的页面，交给 Web Server 返回给浏览器。知乎的主页给大家看到的 html 整体来说是差不多的，都有导航栏，左边是关注的动态，右边是广告和边栏，每一块的整体构造大同小异，只是一些地方内容有所区别。服务器脚本就是利用已知的数据，在这些因人而异的地方填入相应的内容，生成给每个人看的页面。比如我的主页，导航栏右边的头像和名字跟别人看到的不一样，就是因为这块地方有一个放图片的&lt;img&gt;标签和一个写名字的&lt;span&gt;标签，服务器脚本在查询本地的数据之后给我返回的页面里&lt;img&gt;的标签填了我头像的图片链接，&lt;span&gt;标签里填了我的名字，给别人的页面就填其他链接、其他名字，这样每个人看到的页面就不一样了。 .jpg) [caption id=”attachment_47” align=”alignnone” width=”300”] Web建站技术中，HTML、HTML5、XHTML、CSS、SQL、JavaScript、PHP、ASP.NET、WebServices是什么？[/caption] &nbsp; .jpg)PHP 就是一种常见的用来写服务器脚本的语言，其实只要是能拿来写大家传输数据的通用接口（CGI）的语言都可以用来写服务器脚本（也就是说几乎所有编程语言都可以写 = =b），只是因为现成工具的丰富程度和专攻程度不一样，所以有一些语言在写服务器端脚本的时候会比较热门。 为了方便，我们在写服务器脚本的时候，通常还会用个同语言写的 Web Framework 来处理各种细节，防御一些常见的攻击，提供跨站认证（比如用已有的微博账号注册其他网站）的接口，利用cookie处理登陆状态和用户设置，生成网页模版之类的。如果你用 C# 或者 Visual Basic 写服务器脚本，就可以用 http://ASP.NET 这个框架实现这些功能，帮你省点麻烦。不过现在不少人是反过来为了一个好用的 Web Framework 去选择它对应的服务器脚本语言的。 一个普通网站访问的过程简单概括一下，对于我们普通的网站访问，涉及到的技术就是： 用户操作浏览器访问，浏览器向服务器发出一个 HTTP 请求； 服务器接收到 HTTP 请求，Web Server 进行相应的初步处理，使用服务器脚本生成页面； 服务器脚本（利用Web Framework）调用本地和客户端传来的数据，生成页面； Web Server 将生成的页面作为 HTTP 响应的 body，根据不同的处理结果生成 HTTP header，发回给客户端； 客户端（浏览器）接收到 HTTP 响应，通常第一个请求得到的 HTTP 响应的 body 里是 HTML 代码，于是对 HTML 代码开始解析； 解析过程中遇到引用的服务器上的资源（额外的 CSS、JS代码，图片、音视频，附件等），再向 Web Server 发送请求，Web Server 找到对应的文件，发送回来； 浏览器解析 HTML 包含的内容，用得到的 CSS 代码进行外观上的进一步渲染，JS 代码也可能会对外观进行一定的处理； 用户与页面交互（点击，悬停等等）时，JS 代码对此作出一定的反应，添加特效与动画； 交互的过程中可能需要向服务器索取或提交额外的数据（局部的刷新，类似微博的新消息通知），一般不是跳转就是通过 JS 代码（响应某个动作或者定时）向 Web Server 发送请求，Web Server 再用服务器脚本进行处理（生成资源or写入数据之类的），把资源返回给客户端，客户端用得到的资源来实现动态效果或其他改变。注意这只是小网站里比较常见的模型，大网站为了解决规模问题还会有很多处理，每个环节都会有一些细微的差异，中间还会使用各种各样的工具减轻服务器的压力，提高效率，方便日常维护~ 延伸阅读 —— 那些看花眼的名词为了方便调试，很多 Web Framework 会自带一个简单的 Web Server，或者有些 Web Server 会自带一个简单的 Web Framework ，实际部署到服务器上开放使用的时候为了性能或者安全等多方面的考虑，可以把内置的 Web Server 换成其他的，比如 Apache 或者 Nginx （举个栗子，知乎用的是 Tornado 做 Framework，Server 换成了 Nginx，见知乎使用了哪些框架和开源库？）。如果是开源的东西，还可以在遵守开源协议的前提下自己改一下再用~ 因为后端不像前端已经有 HTML + CSS + JS 这样的既定事实标准，服务器脚本与 Web Framework 的选择很多，所以新手会听到很多眼花缭乱的技术名词的地方多在这里~ 举一些栗子，早年常见的服务器端语言有： 开源的 PHP Sun 公司的 JSP 中使用的 Java 微软的 ASP 中使用的 VBScript现在在这方面的应用热起来的语言有 Python，对应常见的 Framework 包括知乎和Quora有用到的 Tornado（其实是自带 Framework 的 Web Server），社区很成熟的 Django （用户包括 Instagram、Pinterest）等 Ruby，一般都用 Rails 这个 Framework，用户包括 Github、早期的 Twitter 等 逆天的 JavaScript，有了 Node.js 这个平台，Web Server、服务器脚本和浏览器脚本全都可以用 JavaScript 来写……Node.js上最常用的 Framework是Express 微软家的则跟着 http://ASP.NET 转移到了C# 或者 Visual Basic Erlang，擅长大规模的并发，不少游戏公司拿来写服务器，靠几十个工程师支撑几亿用户的WhatsApp也是用的这个~几种常见的架构包括： LAMP = Linux + Apache + MySQL + PHP（P还可能是Python或Perl。有时候L会改成W=Windows。），也就是服务器上的操作系统是 Linux，Web Server 用 Apache，数据库用 MySQL，服务器脚本用 PHP，这些都是开源技术，网站起步时用起来的成本会比较低，所以是普通网站里非常常见的架构（虽然对于发展得很大的网站会遇到很多瓶颈），Facebook就是这种，淘宝也曾经是。 J2EE，Java 世界的架构，通常是企业用的（银行、大型公司,.etc），比较常见地还会搭配一种 UNIX 做操作系统，Apache 做 Web Server，Tomcat 转换 JSP 到 Java 给服务器程序用（其实它也自带 Web Server），Oracle 数据库等等。不一定拿来建站，常常用来提供企业里的各种需要用到网络的业务。我们学校教务系统就是用J2EE做的=。= 淘宝现在也是从LAMP转型到了这个。 http://ASP.NET，微软家的架构，通常会搭配 Windows Server 操作系统，SQL Server 数据库，IIS 做 Web Server。StackOverflow和京东（曾经）就是这个架构。 神奇的MEAN架构，MongoDB做数据库，Express做 Web Framework，Angular 做前端的 JavaScript 框架，Node.js 用于编写 Web Server。神奇之处在于这几个东西的语言都是 JavaScript （MongoDB的实现不是，但与外界沟通用的语言是）。因为是比较新的架构，还有待时间的考验，不过被很多人（尤其是靠 JavaScript 吃饭的前端程序猿们）热切关注。 一般来说重点不在技术而且在乎成本的新网站比较喜欢用 LAMP，重视安全稳定和速度的企业和机构喜欢 J2EE，想省事的网站喜欢 http://ASP.NET，比较 Geek 的网站和创业公司喜欢折腾各种 Python、Ruby、Node.js世界的东西，Google 这样现成的技术都解决不了需求的超大型网站就自己折腾解决方案。虽然可以用的语言和所属体系五花八门，其实服务器端程序要做的事情本质上都差不多的，就好比自然世界中要表达“吃过了没”这句话的意思，你可以用各种各样的语言在各种各样的场景里表达出来~ 更多详情: http://www.zhihu.com/question/22689579/answer/22318058 &nbsp;]]></content>
      <categories>
        <category>WEB</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【转】如何删除神不知鬼不觉，删除男友电脑里的游戏但保留图标，让他打开就不能玩？]]></title>
    <url>%2F2016%2F02%2F15%2F44%2F</url>
    <content type="text"><![CDATA[首先，这个方法重装游戏无效重装系统有效有可能被360优化掉 新建文本文档，并将文本文档的后缀名由“txt”改为“vbs”。&nbsp; 右键点击编辑进入文档中执行脚本编辑。&nbsp; 复制如下代码至文本文档中（不包含本行）：&nbsp; 脚本中的第六行设定需要关闭的进程名称，这里的值为“Client.exe”，如果你的男朋友还喜欢玩其他游戏，可以再建立一个，并修改为其主程序文件名。&nbsp; 在这里列出常见游戏/软件名称： 英雄联盟： Client.exe 穿越火线： Crossfire.exe Dota2: Dota2launcher.exe Counter-Strike Global Offense: csgo.exe Battlefield 3: BF3.exe Battlefield 4: BF4.exe Battlefield Bad Company 2: BFBC2.exe Steam: Steam.exe Origin: Origin.exe Uplay: Uplay.exe 地下城与勇士: DNF.exe 求生之路2： L4D2.exe 星际争霸2： StarCraft II.exe 战舰世界： WorldofWarships.exe&nbsp; 脚本中的第九行设定关闭应用程序后的提示信息，这里仿照英雄联盟的出错信息，如果你修改了其他游戏，请自行修改对应报错提示。也可以直接说：找不到D3DX9_42.DLL .&nbsp; 当然你也可以改写为其他提示信息，如“先陪我啪啪啪，然后再让你英雄联盟”。&nbsp; 编辑保存脚本后，双击脚本，脚本便会开始运行（无任何提示信息），此时打开应用管理器，看到wscript.exe，便表示脚本已经开始运行，如果想要停止脚本运行，同样打开应用管理器关闭该进程即可。&nbsp; 将此脚本文件放置到开始菜单的 启动 文件夹中，设置为随系统自启动&nbsp; 祝你有个幸福，美满的人生。&nbsp; 更多详情: http://www.zhihu.com/question/39918426/answer/83829523]]></content>
      <categories>
        <category>杂物</category>
      </categories>
      <tags>
        <tag>游戏</tag>
        <tag>奇技淫巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机专业英语词汇收录]]></title>
    <url>%2F2016%2F02%2F15%2F42%2F</url>
    <content type="text"><![CDATA[recursion 递归 A Active-matrix主动矩阵 Adapter cards 适配卡 Advanced application高级应用 Analytical graph 分析图表 Animations 动画 Arithmetic operations 算术运算 Audio-output device音频输出设备 Access time 存取时间 access存取 accuracy 准确性 ad network cookies广告网络信息记录软件 Add-ons 插件 Analog signals模拟信号 Applets 程序 Asynchronous communications port异步通信端口 Attachment附件 B Bar code条形码 Bar code reader 条形码读卡器 Basic application基础程序 Binary coding schemes 二进制译码方案 Binary system 二进制系统 Bit 比特 Bus line 总线 Backup tape cartridge units 备份磁带盒单元 Bandwidth 带宽 Broadband 宽带 Business-to-business企业对企业电子商务 Business-to-consumer企业对消费者 C Cables连线 ,线缆 Cell单元箱 Chain printer链式打印机 Character and recognition device字符标识识别设备 Chart图表 Chassis支架 Chip芯片 Clarity清晰度 Closed architecture封闭式体系结构 Column列 Combination key结合键 computer competency计算机能力 connectivity连接，结点 Continuous-speech recognition system连续语言识别系统 Control unit操纵单元 Cordless or wireless mouse无线鼠标 Cable modems有线调制解调器 carpal tunnel syndrome腕骨神经综合症 CD-RW可重写光盘 CD-R可记录压缩光盘 Channel信道 Chat group谈话群组 chlorofluorocarbons(CFCs) ]氯氟甲烷 Coaxial cable同轴电缆 [‘kəu’æksəl] cold site冷网站 Commerce servers商业服务器 Communication channel信道 Communication systems信息系统 Compact disc rewritable Compact disc光盘 computer abuse amendments act of 19941994计算机滥用法案 computer crime计算机犯罪 computer ethics计算机道德 computer fraud and abuse act of 1986计算机欺诈和滥用法案 computer matching and privacy protection act of 1988计算机查找和隐私保护法案 computer support specialist计算机支持专家 computer technician计算机技术人员 computer trainer计算机教师 Connection device连接设备 Connectivity连接 Consumer-to-consumer个人对个人 cookies-cutter programs信息记录截取程序 cracker 解密高手 cumulative trauma disorder积累性损伤错乱 Cybercash电子现金 Cyberspace计算机空间 cynic愤世嫉俗者 Database manager数据库管理 Data bus数据总线 Data projector数码放映机 Desktop system unit台式电脑系统单元 Destination file目标文件 Digital cameras数码照相机 Digital notebooks数字笔记本 Digital bideo camera数码摄影机 Discrete-speech recognition system不连续语言识别系统 Dot-matrix printer点矩阵式打印机 [‘meitriks] Dual-scan monitor双向扫描显示器 Dumb terminal 非智能终端 dumb 哑的 Data transmission specifications数据传输说明 database administrator数据库管理员 Dataplay数字播放器 Demodulation解调 denial of service attack拒绝服务攻击 [di’naiəl] Dial-up service拨号服务 Digital cash数字现金 Digital signals数字信号 Digital subscriber line数字用户线路 Digital versatile disc数字化通用磁盘 Digital video disc数字化视频光盘 Direct access直接存取 Directory search目录搜索 disaster recovery plan灾难恢复计划 Disk caching磁盘驱动器高速缓存 Diskette磁盘 Disk磁碟 Distributed data processing system分部数据处理系统 Distributed processing分布处理 Domain code域代码 Downloading下载 DVD 数字化通用磁盘 DVD-R 可写 DVD DVD-RAM DVD随机存取器 DVD-ROM 只读 DVD E e-book电子阅读器 Expansion cards扩展卡 end user终端用户 e-cash电子现金 e-commerce电子商务 electronic cash电子现金 electronic commerce电子商务 electronic communications privacy act of1986电子通信隐私法案 encrypting加密术 energy star能源之星 Enterprise computing企业计算化 environment环境 Erasable optical disks可擦除式光盘 ergonomics人类工程学 ethics道德规范 External modem外置调制解调器 extranet企业外部网 F Fax machine传真机 Field域 Find搜索 FireWire port火线端口 Firmware固件 Flash RAM闪存 Flatbed scanner台式扫描器 Flat-panel monitor纯平显示器 floppy disk软盘 Formatting toolbar格式化工具条 Formula公式 Function函数 fair credit reporting act of 1970公平信用报告法案 Fiber-optic cable光纤电缆 File compression文件压缩 File decompression文件解压缩 filter过滤 firewall防火墙 firewall防火墙 Fixed disk固定硬盘 Flash memory闪存 Flexible disk可折叠磁盘 Floppies磁盘 Floppy-disk cartridge磁盘盒 Formatting格式化 freedom of information act of 1970信息自由法案 frequency频率 frustrated受挫折 Full-duplex communication全双通通信 G General-purpose application通用运用程序 Gigahertz千兆赫 Graphic tablet绘图板 green pc绿色个人计算机 H handheld computer手提电脑 Hard copy硬拷贝 hard disk硬盘 hardware硬件 Help帮助 Host computer主机 Home page主页 Hyperlink超链接 hacker黑客 Half-duplex communication半双通通信 Hard-disk cartridge硬盘盒 Hard-disk pack硬盘组 Head crash磁头碰撞 header标题 help desk specialist帮助办公专家 helper applications帮助软件 Hierarchical network层次型网络 history file历史文件 hits匹配记录 horizontal portal横向用户 hot site热网站 Hybrid network混合网络 I Image capturing device图像获取设备 information technology信息技术 Ink-jet printer墨水喷射印刷机 Integrated package综合性组件 Intelligent terminal智能终端设备 Intergrated circuit集成电路 Interface cards接口卡 Internal modem内部调制解调器 internet telephony网络电话 internet terminal互联网终端 Identification识别 i-drive网络硬盘驱动器 illusion of anonymity匿名幻想 index search索引搜索 information pushers信息推送器 initializing 初始化 instant messaging计时信息 internal hard disk内置硬盘 Internet hard drive 网络硬盘驱动器 intranet企业内部网 J joystick操纵杆 K keyword search关键字搜索 L laser printer激光打印机 Layout files版式文件 Light pen光笔 Locate定位 Logical operations逻辑运算 Lands凸面 Line of sight communication视影通信 Low bandwidth低带宽 lurking潜伏 M Main board主板 Mark sensing标志检测 Mechanical mouse机械鼠标 Memory内存 Menu菜单 Menu bar菜单条 Microprocessor微处理器 Microseconds微秒 Modem card调制解调器 Monitor显示器 computer monitor Motherboard主板 Mouse 鼠标 Multifunctional device多功能设备 Magnetic tape reels磁带卷 Magnetic tape streamers磁带条 mailing list邮件列表 Medium band媒质带宽 metasearch engine整合搜索引擎 Microwave微波 Modem解调器 Modulation解调 N Net PC网络计算机 Network adapter card网卡 Network personal computer网络个人电脑 Network terminal 网络终端 Notebook computer笔记本电脑 Notebook system unit笔记本系统单元 Numeric entry数字输入 national information infrastructure protection act of1996国际信息保护法案 national service provider全国性服务供应商 Network architecture网络体系结构 Network bridge网桥 Network gateway网关 network manager网络管理员 newsgroup新闻组 no electronic theft act of1997无电子盗窃法 Node节点 Nonvolatile storage非易失性存储 O Object embedding对象嵌入 Object linking目标链接 Open architecture开放式体系结构 Optical disk光盘 Optical mouse光电鼠标 Optical scanner光电扫描仪 Outline大纲 off-line browsers离线浏览器 Online storage联机存储 P palmtop computer掌上电脑 Parallel ports并行端口 Passive-matrix被动矩阵 PC card个人计算机卡 Personal laser printer个人激光打印机 Personal video recorder card个人视频记录卡 Photo printer照片打印机 Pixel像素 Platform scanner平版式扫描仪 Plotter绘图仪 Plug and play即插即用 Plug-in boards插件卡 Pointer指示器 Pointing stick指示棍 Port端口 Portable scanner便携式扫描仪 Presentation files演示文稿 Presentation graphics电子文稿程序 Primary storage主存 Procedures规程 Processor处理机 Programming control lanugage程序控制语言 Packets数据包 Parallel data transmission平行数据传输 Peer-to-peer network system点对点网络系统 person-person auction site个人对个人拍卖站点 physical security物理安全 Pits凹面 plug-in插件程序 Polling轮询 privacy隐私权 proactive主动地 programmer程序员 Protocols协议 provider供应商 proxy server代理服务 pull products推取程序 push products推送程序 R RAM cache随机高速缓冲器 Range范围 Record记录 Relational database关系数据库 Replace替换 Resolution分辨率 Row行 Read-only只读 Reformatting重组 regional service provider区域性服务供应商 repetitive motion injury反复性动作损伤 reverse directory反向目录 right to financial privacy act of 1979财产隐私法案 Ring network环形网 S Scanner扫描器 Search查找 Secondary storage device辅助存储设备 Semiconductor半导体 Serial ports串行端口 Server服务器 Shared laser printer共享激光打印机 Sheet表格 Silicon chip硅片 Slots插槽 Smart card智能卡 Soft copy软拷贝 Software suite软件协议 Sorting排序 Source file源文件 Special-purpose application专用文件 Spreadsheet电子数据表 Standard toolbar标准工具栏 Supercomputer巨型机 System cabine 系统箱 System clock时钟 System software系统软件 Satellite/air connection services卫星无线连接服务 search engines搜索引擎 search providers搜索供应者 search services 搜索服务器 Sectors扇区 security安全 Sending and receiving devices发送接收设备 Sequential access顺序存取 Serial data transmission单向通信 signature line签名档 snoopware监控软件 software copyright act of1980软件版权法案 software piracy软件盗版 Solid-state storage固态存储器 specialized search engine专用搜索引擎 spiders网页爬虫 spike尖峰电压 Star network星型网 Strategy方案 subject主题 subscription address预定地址 Superdisk超级磁盘 surfing网上冲浪 surge protector浪涌保护器 systems analyst系统分析师 T Table二维表 Telephony电话学 Television boards电视扩展卡 Terminal 终端 Template模板 Text entry文本输入 Thermal printer 热印刷 Thin client瘦客 Toggle key触发键 Toolbar工具栏 Touch screen触摸屏 Trackball追踪球 TV tuner card电视调谐卡 Two-state system双状态系统 technical writer技术协作者 technostress重压技术 telnet远程登录 Time-sharing system分时系统 Topology拓扑结构 Tracks磁道 traditional cookies传统的信息记录程序 Twisted pair双绞 U Unicode统一字符标准 uploading上传 usenet世界性新闻组网络 V Virtual memory虚拟内存 Video display screen视频显示屏 Voice recognition system声音识别系统 vertical portal纵向门户 video privacy protection act of 1988视频隐私权保护法案 virus checker病毒检测程序 virus病毒 Voiceband音频带宽 Volatile storage易失性存储 voltage surge电涌 W Wand reader 条形码读入 Web 网络 Web appliance 环球网设备 Web page网页 Web site address网络地址 Web terminal环球网终端 Webcam摄像头 What-if analysis假定分析 Wireless revolution无线革命 Word字长 Word processing文字处理 Word wrap自动换行 Worksheet file 工作文件 web auctions网上拍卖 web broadcasters网络广播 web portals门户网站 web sites网站 web storefront creation packages网上商店创建包 web storefronts网上商店 web utilities网上应用程序 web-downloading utilities网页下载应用程序 webmaster web站点管理员 web万维网 Wireless modems无线调制解调器 wireless service provider无线服务供应商 world wide web万维网 worm蠕虫病毒 Write-protect notch写保护口 其他缩写 DVD digital bersatile 数字化通用光盘 IT information technology信息技术 CD compact disc 压缩盘 PDA personal digital assistant个人数字助理 RAM random access memory随机存储器 WWW World Wide Web 万维网 DBMS database management system数据库管理系统 HTML Hypertext Markup Language超文本标示语言 OLE object linking and embedding对象链接入 SQL structured query language结构化查询语言 URL uniform resouice locator统一资源定位器 AGP accelerated graphics port加速图形接口 ALU arithmetic-logic unit算术逻辑单元 CPU central processing unit中央处理器 CMOS complementary metal-oxide semiconductor互补金属氧化物半导体 CISC complex instruction set computer复杂指令集计算机 HPSB high performance serial bus高性能串行总线 ISA industry standard architecture工业标准结构体系 PCI peripheral component interconnect外部设备互连总线 PCMCIA Personal Memory Card International Association个人计算机存储卡国际协会 RAM random-access memory随机存储器 ROM read-only memory只读存储器 USB universal serial bus通用串行总线 CRT cathode-ray tube阴极射线管 HDTV high-definition television高清晰度电视 LCD liquid crystal display monitor液晶显示器 MICRmagnetic-ink character recognition磁墨水字符识别器 OCR optical-character recognition光电字符识别器 OMR optical-mark recognition光标阅读器 TFT thin film transistor monitor薄膜晶体管显示器 Zip disk压缩磁盘 Domain name system（ DNS）域名服务器 file transfer protocol(FTP)文件传送协议 hypertext markup language(HTML)超文本链接标识语言 Local area network（ LAN）局域网 internet relay chat(IRC)互联网多线交谈 Metropolitan area network(MAN)城域网 Network operation system(NOS)网络操作系统 uniform resource locator(URL)统一资源定位器 Wide area network(WAN)广域网 Web server / Web 服务器 well-connected / 连接良好 well-known services / 公认的服务 wide area network, WAN / 广域网 wildcard character / 通配符 wildcarding / 通配符方式 window menu / 窗口菜单 Windows 2000 Server File and Print Servers for Macintosh / Windows 2000 Server 的 Macintosh 文件与打印服务器 Windows 2000 Task Manager / Windows 2000 任务管理器 Windows Internet Name Service, WINS / Windows Internet 命名服务 Windows Management Instrumentation, WMI / Windows 管理规范 Windows Media Services / Windows Media 服务 WINS, Windows Internet Name Service / Windows Internet 命名服务 WINS proxy / WINS 代理 WINS resource / WINS 资源 Winsock wireless communication / 无线通讯 WMI, Windows Management Instrumentation / Windows 管理规范 workgroup / 工作组 X.509v3 certificate / X.509/ 证书 XOR, exclusive OR / 异或 zone / 区域 zone list / 区域列表 zone transfer / 区域传送计算机 专业 英语单词 ccable 电缆cabling 布线cache 高速缓存caching 高速缓存CAD 计算机辅助设计cage 盒子calculate 计算calculation n.计算，统计，估计calculator 计算器calendar 日历calibrate 校准call 调用callback 回叫caller 调用程序calling 调用callout 调出camcorder 便携式摄像机cancel 取消candidate 候选cannot 不能canvas 画布capability 能力capable 有能力的capacitor 电容capacity 能力capital 大写capitalized a.大写的caption 图表说明capture 捕捉card 卡caret 插入记号carousel n.圆盘传送带carriage 托架carrier 载波carry 进位cartridge 盒式磁带cascade 级联case n.情况，场合cash n.现金cassette 盒式磁带cast 强制转型catalog 编目catalogue 编目catch 捕捉category 种类cation n.正离子，阳离子cause 原因caution 注意CD 光盘，激光唱片cedilla 变音符cell 单元Celsius 摄氏center 中心centering 向中对齐centerline 中线centimeter 厘米central 中央的centrex 中央交换机century n.世纪certain a.确实的，确定的certainty n.必然，确实certification 确证chain 链chained 链接chaining 链接chamber 箱change 更改channel 通道channelizing 沟道效应chapter 章char 字符character 字符characteristic 特性charge 费用charging 充电chart 图表chassis 机壳check 检查checker 检查器checkout 检出checkpoint 检查点child 儿子节点children 子女chip 芯片choice 选项choose v.挑选，选择，选定chord 弦chunk n.厚块，大部分ciphertext 密码文本circle n.圆，圈，循环，周期circuit 电路circular 循环circumflex 弯曲circumstance n.情况，环境，细节citation 引用city 城市clamp 夹class 类classify 分类clause 子句clear 清除clearinghouse 清除库clerk 职员click 单击client 客户clip 裁剪clipboard 裁剪板cliping 裁剪clipper n.剪刀clock 时钟clocking 定时clockwise 顺时针方向Close 关闭closed a.关闭的，闭迹closely a.精密地，仔细地cluster 群集coalesce 结合coating 涂层coax 同轴coaxial 同轴的code 代码coder 编码器codeset 代码集coding 编码coefficient 系数coexist 共存coexistence 共存coffret 传输接口collapse 崩溃collate 整理collation 整理collator 整理器collection 堆集collision 冲突colon 冒号colour 颜色column 列combination 组合combine 组合combobox n.组合框comma 逗号command 命令comment 注解commercial a.商业的，经济的commit 落实commitment 落实commodity 商品common 公共的communicate 通信communication n.通信compact 压缩compaction 压缩company 公司comparand 比较字comparator 比较器compare 比较comparison 比较compatibility 兼容性compatible 兼容的compilation 编译compile 编译compiler 编译器complement 补码complementer 反相器complete 完成completely ad.十分，完全，彻底completion 完成complex 复杂的complexities 复杂性complexity 复杂程度complicated v.使复杂化，使混乱component 部件components 部件compose 组成composing 组成composite 合成composition 组合compress 压缩compression 压缩compressor 压缩器comprise vt.包括，由 … 组成compute 计算computer 计算机computing 计算concatenate 并置concatenation 并置concentration 集中concentrator 集线器concept n.概念concordance 重要语汇索引concurrent 同时的condense 压缩condition 条件conditional 条件的conditioning 调节conductor 导线conduit 护线管confidential 机密configuration 配置configurator 配置程序configure 配置confirm 确认confirmation 确认conflict v.冲突，碰头conflicting 冲突conform vi.遵从，符合confuse vt.使混乱，干扰congestion 拥塞conjunction 与connect 连接connected 连接connection 连接connective 连接词connectivity 连通性connector 连接器consecutive 连续的consent 插座consequently ad.因此，从而consider 考虑consideration n.考虑，研究，讨论considered a.考虑过的，被尊重的consist vi.符合，包括consistency 一致性consistent 一致的console 控制台consolidate 合并const n.常数constant 常量constantly ad.不变地，经常地constraint 约束constructing 构造constructor 构造成员consult v.咨询，顾问consumable 消费品consume v.消耗，使用contact 联系contain 包含container 容器containment 包含content 内容contention 争用context 上下文contextual 上下文的contiguous 相连的continue 继续continued 接上页continuously ad.连续不断地contractor 承包方contrast 反差control 控制controllability 可控制性controlled a.受控制的，受操纵的controller 控制器convegence 收敛convenience n.方便，便利convenient a.方便的，便利的convention 约定conventional a.常规的，习惯的converg 收敛converged 收敛的conversation 对话conversational 会话式conversion 转换convert 转换converted 转换的converter 转换器coordinate 坐标coordinator 协调程序coprocessor 协处理器copy 复制copying 复制copyright n.版权cord n.绳子，电线core 核心coresidency 共存corner 角corona 电晕correct 正确correction n.校正，修正correctly 正确correlator 相关因子correspond vi.通信 ( 联系)corresponding 相应的corrupt v.有毛病的corrupted 毁坏的cosine 余弦cost 成本costing 成本法Coulomb 库仑count 计数counter 计数器counterclockwise 反时针方向country 国家coupler 耦合器coupling 耦合courier 信使course n.过程，航向，课程cover 盖CPU 控制处理部件crank 曲柄crash 崩溃craze n.开裂create 建立creation n.创造， 创作creator 建立者credentials 凭证credit 信用crew 组员criteria 标准criterion n.标准，判据，准则critical 临界的crop v.切，剪切cross 跨crossfoot 交叉结算crowding 拥挤cryogenics 低温学cryotron 低温管cryptographic 密码cryptography 密码术CUA 公共用户存取访问culling 挑选cumulative 累积的current 当前currently ad.目前， 现在cursor 光标curtate 卡片部分cushion 缓冲器custom a.用户customation 定制customer 用户customize 定制cut 剪下cutoff 截止cutout 开口cybernetics 控制论cycle 循环cyclinder 柱面cyrill 西里尔计算机 专业 英语单词 ddaemon 守护程序daily a.每日的，日常的damage 损坏damping 阻尼dark 黑暗DASD 直接存取存储器data 数据database 数据库datagram 数据报date 日期datum 数据day 天db 分贝deactivate 释放deactivated 释放deactivation 释放deadlock 死锁deal v.处理，分配，交易dealer 经销商deallocate 释放dearly ad.极，非常，昂贵地death n.毁灭，消灭debit 借额deblock 解块deblocking 解块debug 调试debugger 调试器deca 十（词头）deci 十分之一（词头）decibel 分贝decide v.(使 )判定，判断decimal 十进制decipher 译码decision 判定deck 叠declaration 说明declarative 说明的declarator 说明符declare 说明declared a.承认的，申报的decode 译码decoder 译码器decollate 分开decompression 还原deconcentration 分散deconcentrator 分线器decrease v.减少，降低，缩短decreasing 递减decrement 减decrypt 译码decurl 去卷曲dedicate 专用dedicated 专用的dedication 专用deduction 扣除default 缺省defect 缺陷defective a.故障的，有毛病的definable a.可定义的，可确定的define 定义definition 定义限定deflect 转向degrade v.降低，减少，递降degree 度delay 延迟deleave 拆散delegation 授权delete 删除deletion n.删去 ( 部分) ，删除delimit 定界delimiter 定界符delinquent 拖欠帐款deliver 传递（回叫）delivery 传递demand 需求demangling 识别解码demodulate 解调demodulation 解调demodulator 解调器demographic 人口统计的demon 精灵程序demonstrate v.论证，证明，证实demonstration 示范demount 卸下demultiplex 多路分用demultiplexer 多路分用器denary 十进制的denormal 非正常表示的denote 表示density 密度deny 否认department n.部门，门类，系depend 取决于dependent 从属dependents 从属depress 按下depth 深度deque 双队列dequeue 离队derivation 派生descend 下降descendant 子代describe 描述descried a.被看到的，被发现的description n.描述descriptor 描述信息块deselect 取消选择deserialize 串行变并行deserializer 串并转换器design 设计designate 指定designated a.指定的，特指的designation 指定designlist 设计表desirable a.所希望的，称心的desire v.期望desired 期望的desk n.书桌，控制台，面板desktop 桌面desposition 支配权destage 离台destination 目的地destroy 毁坏destructor 析构成员detached 分离的detail 细节detailed 详细的detect 检测detent 稳定装置deter vt.阻止，拦住，妨碍determinant 行列式值determine 确定develop 开发developer 开发者developing 开发development n.开发，研制deviation 偏差device 设备diacritic 发音符号diacritical a.区分的，辩别的diaeresis 分音符diagnose 诊断diagnostic 诊断的diagnostics 诊断diagonal 对角的diagonally ad.斜 ( 对)diagram 图表dial 拨号dialing 拨号dialog 对话dibit 双位dictionary 字典differ vi.不同，不一致difference 差different 不同的differentiate v.区别，分辨differentiator 微分器digest 整理digit 数字digital 数字digitize 数字化dimension 维dimensional n….维的dimensionality 维数diode 二极管diphthong 元音连字dipping 浸渍法direct 直接的direction 指导directly ad.直接地，立即director 导向器directory 目录dirid 目录标识符dirname 目录名Dirve 驱动器disable 禁用disabled 禁用的disappear vi.消失disassembler 反汇编器disc 磁盘discard v.删除，废除，放弃discarded 废弃的discipline 规程disconnect 断开disconnection 断开discrete 离散的discriminant 判别式discriminator 鉴别器disjunction 析取disk 磁盘diskette 软盘dismount 卸下dispatch 分派dispatcher 调度器dispersant 分散剂displacement 位移display 显示dispose 配置disposition 配置disregard vt.轻视 , 把.. 忽略不计dissector 析象器distinction n.区别，相异，特性distinguish v.区别，辨识distort 失真distortion 失真distribute vt.分布，配线，配给distributed 分布的distribution 分发dithering 抖动ditto 同上diversion 转换divide v.除dividend 被除数division 部分divisor 除数DLL 动态连接库document 文档documentation 文档编制documenting 记录domain 域DOS 磁盘操作系统dot 点double a.两倍的，成双的doublet 二位字节doubleword 双字down 向下download 卸载downstream 顺流draft 草稿drag 拖曳drawable 可绘制的drift 漂移drive 驱动器driver 驱动程序drop 放下drum 磁鼓dryer 干燥器dual a.对偶的，双的due 到期dumb 哑的dummy 哑的dump 转储duodecimal 十二进制的duplex 双工duplicate 重复duplication 复制duplicator 复印机durability 耐用性duration 持续时间during 在期间dynamic 动态dynamicizer 动态转换器]]></content>
      <categories>
        <category>杂物</category>
      </categories>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP中::、->、Self、$this操作符的区别]]></title>
    <url>%2F2016%2F02%2F14%2F31%2F</url>
    <content type="text"><![CDATA[# PHP中::、-&amp;gt;、self、$this操作符的区别在访问PHP类中的成员变量或方法时，如果被引用的变量或者方法被声明成const（定义常量）或者static（声明静态）,那么就必须使用操作符::,反之如果被引用的变量或者方法没有被声明成const或者static,那么就必须使用操作符-&gt;。另外，如果从类的内部访问const或者static变量或者方法,那么就必须使用自引用的self，反之如果从类的内部访问不为const或者static变量或者方法,那么就必须使用自引用的$this。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++sort()函数的用法]]></title>
    <url>%2F2016%2F02%2F14%2F29%2F</url>
    <content type="text"><![CDATA[## C++sort()函数的用法## 近来看了c++标准库这本书，学到了很多，就把这其中的一点C++sort()函数的用法写下来和大家分享吧！（一）为什么要用c++标准库里的排序函数Sort（）函数是c++一种排序方法之一，学会了这种方法也打消我学习c++以来使用的冒泡排序和选择排序所带来的执行效率不高的问题！因为它使用的排序方法是类似于快排的方法，时间复杂度为n*log2(n)，执行效率较高！（二）c++标准库里的排序函数的使用方法I）Sort函数包含在头文件为#include&lt;algorithm&gt;的c++标准库中，调用标准库里的排序方法可以不必知道其内部是如何实现的，只要出现我们想要的结果即可！II）Sort函数有三个参数：（1）第一个是要排序的数组的起始地址。（2）第二个是结束的地址（最后一位要排序的地址）（3）第三个参数是排序的方法，可以是从大到小也可是从小到大，还可以不写第三个参数，此时默认的排序方法是从小到大排序。Sort函数使用模板:Sort(start,end,排序方法)下面就具体使用sort（）函数结合对数组里的十个数进行排序做一个说明！例一：sort函数没有第三个参数，实现的是从小到大#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int main(){int a[10]={9,6,3,8,5,2,7,4,1,0};for(int i=0;i&lt;10;i++)cout&lt;&lt;a[i]&lt;&lt;endl;sort(a,a+10);for(int i=0;i&lt;10;i++)cout&lt;&lt;a[i]&lt;&lt;endl;return 0;}例二通过上面的例子，会产生疑问：要实现从大到小的排序肿么办？这就如前文所说需要在sort（）函数里的第三个参数里做文章了，告诉程序我要从大到小排序！需要加入一个比较函数 complare(),此函数的实现过程是这样的bool complare(int a,int b){return a&gt;b;}这就是告诉程序要实现从大到小的排序的方法！#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;bool complare(int a,int b){return a&gt;b;}int main(){int a[10]={9,6,3,8,5,2,7,4,1,0};for(int i=0;i&lt;10;i++)cout&lt;&lt;a[i]&lt;&lt;endl;sort(a,a+10,complare);//在这里就不需要对complare函数传入参数了，//这是规则for(int i=0;i&lt;10;i++)cout&lt;&lt;a[i]&lt;&lt;endl;return 0;}例三：通过上面例一、二的方法虽然实现了从大到小和从大到小的排序，这样做还是有点麻烦，因为还需要自己编写告诉程序执行何种排序的原则的函数，c++标准库强大的功能完全可以解决这种麻烦。Sortt函数的第三个参数可以用这样的语句告诉程序你所采用的排序原则less&lt;数据类型&gt;()//从小到大排序greater&lt;数据类型&gt;()//从大到小排序结合本例子，这样的就可以完成你想要的任何一种排序原则了#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int main(){int a[10]={9,6,3,8,5,2,7,4,1,0};for(int i=0;i&lt;10;i++)cout&lt;&lt;a[i]&lt;&lt;endl;sort(a,a+10,less&lt;int&gt;());for(int i=0;i&lt;10;i++)cout&lt;&lt;a[i]&lt;&lt;endl;return 0;}#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int main(){int a[10]={9,6,3,8,5,2,7,4,1,0};for(int i=0;i&lt;10;i++)cout&lt;&lt;a[i]&lt;&lt;endl;sort(a,a+10,greater&lt;int&gt;());for(int i=0;i&lt;10;i++)cout&lt;&lt;a[i]&lt;&lt;endl;return 0;}例四：利用sort函数还可以实现对字符的排序，排序方法大同小异，下面就把程序范例展示一下#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int main(){char a[11]=”asdfghjklk”;for(int i=0;i&lt;10;i++)cout&lt;&lt;a[i]&lt;&lt;endl;sort(a,a+10,greater&lt;char&gt;());for(int i=0;i&lt;10;i++)cout&lt;&lt;a[i]&lt;&lt;endl;return 0;}]]></content>
      <categories>
        <category>ACM</category>
        <category>c++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最大公约数与最小公倍数]]></title>
    <url>%2F2016%2F02%2F14%2F27%2F</url>
    <content type="text"><![CDATA[#include &lt;stdio.h&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt;using namespace std; / run this program using the console pauser or add your own getch, system(“pause”) or input loop / //最小公倍数: 两整数相乘 / 最大公约数; int main(int argc, char** argv) {int fuc(int a,int b);int a,b;while(cin&gt;&gt;a&gt;&gt;b){ cout&lt;&lt;a*b / fuc(a,b)&lt;&lt;endl;} return 0;} int fuc(int a,int b) //辗转相除法求最大公约数{int c;int temp;if(a&lt;b) //使得a&gt;b{temp = a;a = b;b = temp;} c = a % b; //关键步骤while(c!=0){ a = b;b = c;c = a % b;}return b; }]]></content>
      <categories>
        <category>ACM</category>
        <category>c++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Php的url路由技术]]></title>
    <url>%2F2016%2F02%2F14%2F25%2F</url>
    <content type="text"><![CDATA[统一处理请求的地址，根据请求的地址参数，分别执行不同程序，这在MVC模式构架的项目里是很常见的，比如：请求地址是http://demo.com/index.php?m=news&amp;c=article&amp;a=list所有的请求都走index.php，然后在index.php里面接受三个参数分别是new，article，list，根据这三个参数去找要执行的程序，比如这里要执行news模块下的acticle控制器里的list方法，这只是一个典型例子而以，当然情况多变，根据你的需求来]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【转】如何着手学习一个新的PHP框架]]></title>
    <url>%2F2016%2F02%2F14%2F23%2F</url>
    <content type="text"><![CDATA[如何着手学习一个新的PHP框架**如今的PHP框架层出不穷，名气也各不相同。如何快速掌握一种框架？看看本文吧~如今的PHP框架层出不穷，名气也各不相同。我不是这方面的专家，甚至不能熟练地使用其中的一种，所以就不作推荐了。这里我要讨论的是如何才能更快地开始使用某个框架。 首先你当然必须选择一个框架，比如ZF、Cake、Symfony、atk、Yii、CodeIgniter、Solar、PRADO等。选择哪个呢？有些框架提供了非常好的入门教程，另一些则比较难入门了。 我很喜欢这篇文章：《学习一种新的编程语言所需做的练习》，但我因为已经很熟悉PHP了，所以这个方法不能用在学习框架上。所以我想列举一些类似的练习用以学习PHP框架。如果已经学会了一个php框架，再去学习其他php框架，那么会很容易上手。但是如果还没有php框架基础，想去学习php框架，往往是一头雾水，不知道从哪里下手，从我学习php框架的经验，给大家分享一下，如何快速的去学习并掌握一个框架。第一步，把下载回来的框架压缩包解压，然后把每个目录和文件名，大致的浏览一遍。这样可以大概看出，这个php框架中大致布局和具有哪些功能。第二步，学习输出hello world，hello world很简单，但是对于学习一门新的语言或框架，很重要。第三步，写一个简单的计算器程序，结合表单，对两个操作数进行加减乘除等运算，并把结果输出到页面上。第四步，留言本 程序，在页面上显示一个表单让用户填写，然后提交到这个应用程序里，继而存储到数据库或文本文件中（视你自己的情况而定），并把用户留言的内容显示到页面上。如果框架提供了创建HTML表单、对象模型或层等功能，就用上它们吧。第五步，学习理解单一入口和网址解析（即网址路由），单一入口，对于新手来说，可能有点不太好理解。第六步，解析和分页，选一个RSS源或其他XML源，解析其中的条目并显示出来。同时添加一个分页的功能，让用户可以五条五条地浏览，并在页面的顶部或底部添加页码。第七步，学习php框架的内置的模板操作，主要学习程序是怎么赋值给模板，怎么加载模板和常用的模板标签第八步，学习数据库的添加，修改，删除，查询，学会简单的数据库操作。第九步，学习php框架常用的函数和类库，php框架中一般会带一些常用的函数和类，可以稍微看一下，此时还没有必要深入研究，等用到的时候再详细的去看手册和样例。第十步，下载基于此框架开源的项目系统下来学习，了解了php框架的执行流程，模板操作，和数据库操作，下载一个开源的系统，下来去学习，学习别人的代码，学得更快。第十一步，做项目学习，要熟练掌握一个的框架，需要大量的实践，通过做项目，去深入学习。第十二步，阅读框架代码，了解其实现原理最后，到这一步，你已经学会了这个php框架。 完成以上的练习后，你应该就可以清楚地知道如何使用这个框架了，并能用它完成更复杂的工作，或是继续探索这个框架的其他功能。如果你还是不会用，或者花了很多时间来完成以上练习，那么我觉得这个框架不适合你，还是找些其他的来用吧。 记住，如果在使用框架的过程中遇到困难，记得去该框架的社区里寻求帮助。一个有这强大社区支持的框架会为你未来的工作带来很大帮助，同时也表明这个框架是个不错的框架。没有人希望在使用某框架后的六个月，框架的开发者就宣布停止开发，这就太气人了。作者：Wicub出处：http://www.cnblogs.com/wicub免责声明：文章、笔记等仅供分享、探讨、参考等学习之用，因此造成的任何后果概不负责。（如有错误、疏忽等问题，欢迎指正、讨论，谢谢）本文版权归作者和博客园共有，欢迎转载，但请务必在文章页面明显位置给出原文连接，谢谢配合。**]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Json语法]]></title>
    <url>%2F2016%2F02%2F14%2F21%2F</url>
    <content type="text"><![CDATA[书写格式： 名称/值对“name”:”小明”,{“staff”:[{“name”:”name1”,”age”:”70”},{“name”:”name3”,”age”:”70”},{“name”:”name2”,”age”:”70”},]}]]></content>
      <categories>
        <category>json</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[节点属性]]></title>
    <url>%2F2016%2F02%2F14%2F19%2F</url>
    <content type="text"><![CDATA[节点属性在文档对象模型 (DOM) 中，每个节点都是一个对象。DOM 节点有三个重要的属性 ：1. nodeName : 节点的名称2. nodeValue ：节点的值3. nodeType ：节点的类型一、nodeName 属性: 节点的名称，是只读的。1. 元素节点的 nodeName 与标签名相同2. 属性节点的 nodeName 是属性的名称3. 文本节点的 nodeName 永远是 #text4. 文档节点的 nodeName 永远是 #document二、nodeValue 属性：节点的值1. 元素节点的 nodeValue 是 undefined 或 null2. 文本节点的 nodeValue 是文本自身3. 属性节点的 nodeValue 是属性的值三、nodeType 属性: 节点的类型，是只读的。以下常用的几种结点类型:元素类型 节点类型元素 1属性 2文本 3注释 8 文档 9]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[比较输入数字与随机数组首元素大小]]></title>
    <url>%2F2016%2F02%2F14%2F14%2F</url>
    <content type="text"><![CDATA[#include “stdafx.h” #include &lt;string&gt; #include &lt;iostream&gt; #include &lt;ctime&gt; #include &lt;cstdlib&gt; using namespace std; / run this program using the console pauser or add your own getch, system(“pause”) or input loop / int myCompare(const int j, const int a[]); int main(int argc, char** argv) { srand(( unsigned)time(NULL )); int a[10]; for (auto &amp;i : a) i = rand() % 10; cout &lt;&lt; “enter a number:” &lt;&lt; endl; int j; cin &gt;&gt; j; cout &lt;&lt; “您输入的数与数组首元素中较大的是：” &lt;&lt; myCompare(j, a) &lt;&lt; endl; cout &lt;&lt; “数组的全部元素是：” &lt;&lt; endl; for (auto i : a) cout &lt;&lt; i &lt;&lt; ‘ ‘; cout &lt;&lt; endl; return 0; } int myCompare(const int j, const int *a) { return (j &gt; a) ? j : a; }]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[转]大数运算的算法]]></title>
    <url>%2F2016%2F02%2F14%2F5%2F</url>
    <content type="text"><![CDATA[# 在数学运算的过程中 ,经常碰到这样的问题:参与运算的 数字很大或者对运算结果的精度要求很高。无论何种计算机 语言 ,在描述数据类型时都有一定的精度和位数要求 ,比如说 16 位整型数 (int) 所能表示的范围为 - 32768～32767 ,实数 (float)所能表示的精度为小数点后 8 位等 ,每种类型的数据都 有其精度和位数限制。超过 20 位有效数字的数值一般就无 法表示了。所以 ,在上述情况下 ,采用一般的程序设计无法满 足要求 ,必须采用高精度的数学运算才能实现。如下例: 示例 1 :Fibonacci NumbersA Fibonacci sequence is calculated by adding the previoustwo members of the sequence , with the first two members beingboth 1. f (1) = 1 , f(2) = 1 , f (n &gt; 2) = f (n - 1) + f(n - 2)Your task is to take a number as input , and print that Fi2b onacci number.Sample Input100Sample Output354224848179261915075Note: No generated Fibonacci number in excess of 1000 digits will be in the test data , i. e. f (20) = 6765 has 4 digits.这个示例的计算结果可能很大 ,以至于所有的数据类型 都无法表达。所以我们必须用高精度数学运算相应的算法进 行求解。## 1.大数存储的实现作为实现大数存储最常见的一类方法是利用数组。将一 个有 n 位的大数存入数组 ,每个数组的一个元素表示一位十 进制数 ,若是 n 没有超过普通 PC 机允许的定义范围 ,这种算 法是简单易行的。 如果出现超大数 ,则可以采用万进制的方法加以存储 ,在 此就不多做介绍了。## 2.大数计算的算法这里仅对大数加法的算法做详细描述 ,剩下的运算给出 算法 ,具体程序实现过程留给读者思考。2. 1 大数加法看下面一个例子:122345678902345+ 34567890012122380246792357在上面的加法运算中 ,并没有考虑参与运算的数的位数 , 即使有小数也是一样。每次运算时只是利用加法运算的规则 对参与运算的每一位进行运算 ,每次运算都是在 10 以内进 行 ,并加上了前面的进位。通过这种运算就可以非常准确的 得到运算结果 ,并且可以不考虑位数和精度的问题。 考虑到计算机的存储问题 ,如果我们采用数组来存储参 与运算的每个加数 ,则需要将上面参与运算的数看成字符 ,并 将原来的数翻转 ,即采用下面的运算方法:543209876543221+ 21009876543753297642083221我们看到运算结果与实际结果相反 ,因此只需要将结果 再翻转一次输出即可得到正确结果。这样做的好处在于一旦 遇到低位向高位进位时 ,不会出现存储上的问题。因为最高 位存储在数组的最后一个元素 ,其后的存储单元可用于存放 进位 ,同时运算是从数组的第一个元素开始的。 如何用 C语言来求解上面的加法运算呢 ? 我们须首先定 义一个存储结构来存储每一个数。由于我们采用数组来存储 每一个数 ,如果数的最大位数未知 ,则需采用指针方式定义 , 如果已知则可采用数组的方式来定义 ,在该示例中 ,其最大位 数不超过 1000 位 ,因此可采用数组方式来定义 ,但由于每个 数的实际情况各不相同 ,因此还必须定义一个变量来表示每 个数实际的位数。其存储结构用 C语言表示如下:typedef struct fanum{char fnum[1001] ; / / 数 int len; / / 数的长度}Fanum;基于上面的存储结果及算法 ,我们可采用如下的 C 语言 程序实现两个多位数的加法运算 ,注意该数为整数。void strAdd(Fanum3sf1 ,Fanum3sf2){int i ,len ,flag = 0 ;Fanum sf3 ;len = sf1 - &gt; len &gt; sf2 - &gt; len ? sf1 - &gt; len:sf2 - &gt; len;sf3. len = len; for(i = 0 ;i &lt; len;i + + ){sf3.fnum[i] = sf1 - &gt; fnum[i] - ’0’ + sf2 - &gt; fnum[i] - ’0 ’+flag;flag = sf3.fnum[i]/ 10 ;sf3.fnum[i] = sf3.fnum[i] %10 +’0 ’;} if (flag = = 1){sf3.fnum[i] =’1 ’;sf3. len + + ;} for(i = 0 ;i &lt; sf3. len;i + + ){sf1 - &gt;fnum[i] = sf2 - &gt;fnum[i] ;sf1 - &gt; len = sf2 - &gt; len;sf2 - &gt;fnum[i] = sf3.fnum[i] ;sf2 - &gt; len = sf3.len;}return;}注意此处用 sf1 存储加法运算的结果 ,sf2 用于存储运算 前 sf1 中存储的变量 ,主要是为了能够与上面的示例更相吻 合。 有了上面的函数 ,要完成该题所规定的任务 ,只需要如下 的主程序便可实现。int main(){FILEin ,out ;Fanum f1 ,f2 ;long num ,i ;in =fopen(“ in. txt” , “r” ) ;out =fopen(“out. txt” , “w” ) ;while( fscanf (in ,“%d” , &amp;num) ! = EOF){ f1. len = 1 ; f2. len = 1 ; for(i = 0 ;i &lt; 1001 ;i + + ){ f1.fnum[i] =’0 ’; f2.fnum[i] =’0 ’; }f1.fnum[0] =’1 ’;f2.fnum[0] =’1 ’;while(num ! = 2){ strAdd( &amp;f1 , &amp;f2) ; num - - ; }for(i =f2. len - 1 ;i &gt; = 0 ;i - - )fprintf (out ,“%d” ,f2.fnum[i] - ’0 ’) ;fprintf (out ,“ \ n” ) ; }fclose(in) ; fclose(out) ;return 1 ;}该题输入数据存放在 in. txt 文件中 ,而输出结果存放在 out. txt 文件中。 大数加法运算实现算法如下:(1)将 A、 B 按位对齐;(2)低位开始逐位相加;(3)对结果做进位调整。## 2. 2 大数减法大数减法运算实现算法如下:(1)将 A、 B 按位对齐;(2)低位开始逐位相减;(3)对结果做借位调整。## 2. 3 大数乘法大数乘法运算实现算法如下:(1)引入 sum2 、 sum1 中间过渡量;(2)在 n 的每一位上处理 m;(3)通过每一层循环 ,实现乘法的加法化;(4)对结果做进位调整。## 2. 4 大数除法大数除法运算实现算法如下:(1)引入 al 来标识 a 的长度 , bl 来标识 b 的长度;(2)测算 a 和 b 的长度;(3)高位开始 ,对位做减法 ,并完成借位;(4)高位开始逐位计算商; (5)整理商 , 产生余数。## 2. 5 大数取模在取模运算中用到了上面的除法运算 ,只需返回余数即 可。## 3.结论大数运算实际上都是建立在位运算的基础上的 ,实际上 就是对存储大数的数组里每一个数组项进行操作。将大数翻 转过来存储是为了防止在计算过程中出现进位不好表示和溢 出的问题。这种处理也可以看作是对字符串的处理 ,即把这 个数组里的每一位数字转化成字符进行处理。同时如果涉及 到小数 ,如果是加法运算 ,可以把小数点前后的数据分开处 理;如果是乘法运算 ,可将其转换成整数运算之后 ,再转换成 小数。参考文献: [1]王永祥.超高精度超大数算法与程序设计[M].陕西:西安交通 大学出版社. 1990. 6. [2]王昌锐.大数论[M]. 台北:徐氏基金会. 1970. [3]王金荣 等.大数模乘算法的分析与研究[J ]. 计算机工程与应 用. 2004. 24. [4]Robert L. Kruse ,Alexander J. Ryba.“Data Structures And Pro2g ram Design In C+ + ” . Higher Education Press Pearson Education. 5 , 2001.}]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
</search>